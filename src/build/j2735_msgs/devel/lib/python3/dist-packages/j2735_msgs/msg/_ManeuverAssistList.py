# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from j2735_msgs/ManeuverAssistList.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import j2735_msgs.msg

class ManeuverAssistList(genpy.Message):
  _md5sum = "2086e09532cefc78ee69224b474da338"
  _type = "j2735_msgs/ManeuverAssistList"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# This entry is used directly by one other data structure in this standard, a DF called DF_LaneAttributes <ASN>.
#  In addition, this item may be used by data structures in other ITS standards.
# ManeuverAssistList ::= SEQUENCE (SIZE(1..16)) OF ConnectionManeuverAssist

j2735_msgs/ConnectionManeuverAssist[] connection_maneuver_assist_list

================================================================================
MSG: j2735_msgs/ConnectionManeuverAssist

# The ConnectionManeuverAssist data frame contains information about the the dynamic flow of traffic for the lane(s)
# and maneuvers in question (as determined by the LaneConnectionID). Note that this information can be sent regarding
# any lane-to-lane movement; it need not be limited to the lanes with active (non-red) phases when sent.
#
# ConnectionManeuverAssist ::= SEQUENCE {
# connectionID LaneConnectionID,
# -- the common connectionID used by all lanes to which
# -- this data applies
# -- (this value traces to ConnectsTo entries in lanes)
# -- Expected Clearance Information
# queueLength ZoneLength OPTIONAL,
# -- Unit = 1 meter, 0 = no queue
# -- The distance from the stop line to the back
# -- edge of the last vehicle in the queue,
# -- as measured along the lane center line.
# availableStorageLength ZoneLength OPTIONAL,
# -- Unit = 1 meter, 0 = no space remains
# -- Distance (e.g. beginning from the downstream
# -- stop-line up to a given distance) with a high
# -- probability for successfully executing the
# -- connecting maneuver between the two lanes
# -- during the current cycle.
# -- Used for enhancing the awareness of vehicles
# -- to anticipate if they can pass the stop line
# -- of the lane. Used for optimizing the green wave,
# -- due to knowledge of vehicles waiting in front
# -- of a red light (downstream).
# -- The element nextTime in TimeChangeDetails
# -- in the containing data frame contains the next
# -- timemark at which an active phase is expected,
# -- a form of storage flush interval.
# waitOnStop WaitOnStopline OPTIONAL,
# -- If "true", the vehicles on this specific connecting
# -- maneuver have to stop on the stop-line and not
# -- to enter the collision area
# pedBicycleDetect PedestrianBicycleDetect OPTIONAL,
# -- true if ANY ped or bicycles are detected crossing
# -- the above lanes. Set to false ONLY if there is a
# -- high certainty that there are none present,
# -- otherwise element is not sent.
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-ConnectionManeuverAssist}} OPTIONAL,
# ...
# }

# LaneConnectionID ::= INTEGER (0..255)
uint8 connection_id

# ZoneLength ::= INTEGER (0..10000)
# -- Unit = 1 meter, 0 = unknown,
# -- The value 10000 to be used for Distances >=10000 m
# -- (e.g. from known point to another point along a
# -- known path, often against traffic flow direction
# -- when used for measuring queues)
uint16 queue_length
bool queue_length_exists

# ZoneLength ::= INTEGER (0..10000)
uint16 available_storage_length
bool available_storage_length_exists

# WaitOnStopline ::= BOOLEAN --- True or False
# -- If "true", the vehicles on this specific connecting
# -- maneuver have to stop on the stop-line
# -- and not to enter the collision area
bool wait_on_stop
bool wait_on_stop_exists

# PedestrianBicycleDetect ::= BOOLEAN
# -- true if ANY Pedestrians or Bicyclists are
# -- detected crossing the target lane or lanes
bool ped_bicycle_detect
bool ped_bicycle_detect_exists

# regional #TODO: RegionalExtensions are not yet implemented in asn1c"""
  __slots__ = ['connection_maneuver_assist_list']
  _slot_types = ['j2735_msgs/ConnectionManeuverAssist[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       connection_maneuver_assist_list

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(ManeuverAssistList, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.connection_maneuver_assist_list is None:
        self.connection_maneuver_assist_list = []
    else:
      self.connection_maneuver_assist_list = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.connection_maneuver_assist_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.connection_maneuver_assist_list:
        _x = val1
        buff.write(_get_struct_BHBH5B().pack(_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.connection_maneuver_assist_list is None:
        self.connection_maneuver_assist_list = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.connection_maneuver_assist_list = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.ConnectionManeuverAssist()
        _x = val1
        start = end
        end += 11
        (_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists,) = _get_struct_BHBH5B().unpack(str[start:end])
        val1.queue_length_exists = bool(val1.queue_length_exists)
        val1.available_storage_length_exists = bool(val1.available_storage_length_exists)
        val1.wait_on_stop = bool(val1.wait_on_stop)
        val1.wait_on_stop_exists = bool(val1.wait_on_stop_exists)
        val1.ped_bicycle_detect = bool(val1.ped_bicycle_detect)
        val1.ped_bicycle_detect_exists = bool(val1.ped_bicycle_detect_exists)
        self.connection_maneuver_assist_list.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.connection_maneuver_assist_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.connection_maneuver_assist_list:
        _x = val1
        buff.write(_get_struct_BHBH5B().pack(_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.connection_maneuver_assist_list is None:
        self.connection_maneuver_assist_list = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.connection_maneuver_assist_list = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.ConnectionManeuverAssist()
        _x = val1
        start = end
        end += 11
        (_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists,) = _get_struct_BHBH5B().unpack(str[start:end])
        val1.queue_length_exists = bool(val1.queue_length_exists)
        val1.available_storage_length_exists = bool(val1.available_storage_length_exists)
        val1.wait_on_stop = bool(val1.wait_on_stop)
        val1.wait_on_stop_exists = bool(val1.wait_on_stop_exists)
        val1.ped_bicycle_detect = bool(val1.ped_bicycle_detect)
        val1.ped_bicycle_detect_exists = bool(val1.ped_bicycle_detect_exists)
        self.connection_maneuver_assist_list.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_BHBH5B = None
def _get_struct_BHBH5B():
    global _struct_BHBH5B
    if _struct_BHBH5B is None:
        _struct_BHBH5B = struct.Struct("<BHBH5B")
    return _struct_BHBH5B
