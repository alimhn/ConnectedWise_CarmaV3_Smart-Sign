# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from j2735_msgs/IntersectionStateList.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import j2735_msgs.msg

class IntersectionStateList(genpy.Message):
  _md5sum = "3c3e465a240b59411de29f191c748f3e"
  _type = "j2735_msgs/IntersectionStateList"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """#
# IntersectionStateList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The IntersectionStateList data frame consists of a list of IntersectionState entries.

# IntersectionStateList ::= SEQUENCE (SIZE(1..32)) OF IntersectionState

j2735_msgs/IntersectionState[] intersection_state_list
================================================================================
MSG: j2735_msgs/IntersectionState
#
# IntersectionState.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The IntersectionState data frame is used to convey all the SPAT information for a single intersection. Both current
# and future data can be sent.
#
# IntersectionState ::= SEQUENCE {
# 	name DescriptiveName OPTIONAL,
# 	-- human readable name for intersection
# 	-- to be used only in debug mode
# 	id IntersectionReferenceID,
# 	-- A globally unique value set, consisting of a
# 	-- regionID and intersection ID assignment
# 	-- provides a unique mapping to the
# 	-- intersection MAP in question
# 	-- which provides complete location
# 	-- and approach/move/lane data
# 	revision MsgCount,
# 	status IntersectionStatusObject,
# 	-- general status of the controller(s)
# 	moy MinuteOfTheYear OPTIONAL,
# 	-- Minute of current UTC year
# 	-- used only with messages to be archived
# 	timeStamp DSecond OPTIONAL,
# 	-- the mSec point in the current UTC minute that
# 	-- this message was constructed
# 	enabledLanes EnabledLaneList OPTIONAL,
# 	-- a list of lanes where the RevocableLane bit
# 	-- has been set which are now active and
# 	-- therefore part of the current intersection
# 	states MovementList,
# 	-- Each Movement is given in turn
# 	-- and contains its signal phase state,
# 	-- mapping to the lanes it applies to, and
# 	-- point in time it will end, and it
# 	-- may contain both active and future states
# 	maneuverAssistList ManeuverAssistList OPTIONAL,
# 	-- Assist data
# 	regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-IntersectionState}} OPTIONAL,
# 	...
# }

# name DescriptiveName OPTIONAL := IA5String (SIZE(1..63))
# -- often for debug use only
# -- but at times used to name ped crossings
# NOTE: As optional field, blank value can note that it's not set in carma.
string name
bool name_exists

j2735_msgs/IntersectionReferenceID id

#MsgCount ::= INTEGER (0..127)
uint8 revision

j2735_msgs/IntersectionStatusObject status

#MinuteOfTheYear OPTIONAL ::= INTEGER (0..527040)
# The value of 527040 shall be used for invalid
uint32 moy
uint32 MOY_INVALID=527040
bool moy_exists

#DSecond ::= INTEGER (0..65535)
#  -- Integer values from 0 to 59999 represent the milliseconds within a minute
#  -- A leap second is represented by the value range 60000 to 60999
#  -- The values from 61000 to 65534 are reserved
#  -- The value of 65535 shall represent an unavailable value in the range of the minute
#  -- Unit is milliseconds
uint32 time_stamp
uint32 TIME_STAMP_UNAVAILABLE=65535
bool time_stamp_exists

# enabledLanes EnabledLaneList
# This is a list therefore can be empty list in ROS.
j2735_msgs/EnabledLaneList enabled_lanes
bool enabled_lanes_exists

# 	states MovementList
j2735_msgs/MovementList states

# 	maneuverAssistList ManeuverAssistList
j2735_msgs/ManeuverAssistList maneuever_assist_list
bool maneuever_assist_list_exists

# regional #TODO: RegionalExtensions are not yet implemented in asn1c

================================================================================
MSG: j2735_msgs/IntersectionReferenceID
#
# IntersectionReferenceID.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The IntersectionReferenceID data frame conveys the combination of an optional RoadRegulatorID and of an
# IntersectionID that is unique within that region. When the RoadRegulatorID is present the IntersectionReferenceID is
# guaranteed to be globally unique.

# region RoadRegulatorID OPTIONAL ::= INTEGER (0..65535)
# -- a globally unique regional assignment value
# -- typical assigned to a regional DOT authority
# -- the value zero shall be used for testing needs
# 0 is a J2735 value for testing needs, and carma can use it to indicate optional field was not set or unavailable.
uint16 region
uint16 REGION_UNAVAILABLE=0
bool region_exists

# id IntersectionID ::= INTEGER (0..65535)
# -- a unique mapping to the intersection
# -- in question within the above region of use
uint16 id

================================================================================
MSG: j2735_msgs/IntersectionStatusObject
#
# IntersectionStatusObject.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The Intersection Status Object contains Advanced Traffic Controller (ATC) status information that may be sent to
# local OBUs as part of the SPAT process.

# IntersectionStatusObject ::= BIT STRING {
# manualControlIsEnabled (0),
# -- Timing reported is per programmed values, etc. but person
# -- at cabinet can manually request that certain intervals are
# -- terminated early (e.g. green).
# stopTimeIsActivated (1),
# -- And all counting/timing has stopped.
# failureFlash (2),
# -- Above to be used for any detected hardware failures,
# -- e.g. conflict monitor as well as for police flash
# preemptIsActive (3),
# signalPriorityIsActive (4),
# -- Additional states
# fixedTimeOperation (5),
# -- Schedule of signals is based on time only
# -- (i.e. the state can be calculated)
# trafficDependentOperation (6),
# -- Operation is based on different levels of traffic parameters
# -- (requests, duration of gaps or more complex parameters)
# standbyOperation (7),
# -- Controller: partially switched off or partially amber flashing
# failureMode (8),
# -- Controller has a problem or failure in operation
# off (9),
# -- Controller is switched off
# -- Related to MAP and SPAT bindings
# recentMAPmessageUpdate (10),
# -- Map revision with content changes
# recentChangeInMAPassignedLanesIDsUsed (11),
# -- Change in MAP's assigned lanes used (lane changes)
# -- Changes in the active lane list description
# noValidMAPisAvailableAtThisTime (12),
# -- MAP (and various lanes indexes) not available
# noValidSPATisAvailableAtThisTime (13)
# -- SPAT system is not working at this time
# -- Bits 14,15 reserved at this time and shall be zero
# } (SIZE(16))

uint16 intersection_status_object
================================================================================
MSG: j2735_msgs/EnabledLaneList
#
# EnabledLaneList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The Enabled Lane List data frame is a sequence of lane IDs for lane objects that are activated in the current map
# configuration. These lanes, unlike most lanes, have their RevocableLane bit set to one (asserted). Such lanes are not
# considered to be part of the current map unless they are in the Enabled Lane List. This concept is used to describe all the
# possible regulatory states for a given physical lane.
#
# EnabledLaneList ::= SEQUENCE (SIZE(1..16)) OF LaneID
#-- The unique ID numbers for each
#-- lane object which is 'active'
#-- as part of the dynamic map contents.

# LaneID ::= INTEGER (0..255)
# -- the value 0 shall be used when the lane ID is not available or not known
# -- the value 255 is reserved for future use
uint16[] lane_id_list
================================================================================
MSG: j2735_msgs/MovementList
#
# MovementList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The MovementList data frame consists of a list of MovementState entries.
#
# MovementList ::= SEQUENCE (SIZE(1..255)) OF MovementState

j2735_msgs/MovementState[] movement_list
================================================================================
MSG: j2735_msgs/MovementState
#
# MovementState.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The MovementState data frame is used to convey various information about the current or future movement state of
# a designated collection of one or more lanes of a common type. This is referred to as the GroupID. Note that lane object
# types supported include both motorized vehicle lanes as well as pedestrian lanes and dedicated rail and transit lanes. Of
# the reported data elements, the time to change (the time remaining in the current state) is often of the most value. Lanes
# with a common state (typically adjacent sets of lanes in an approach) in a signalized intersection will have individual lane
# values such as total vehicle counts, summed. It is used in the SPAT message to convey every active movement in a
# given intersection so that vehicles, when combined with certain map information, can determine the state of the signal
# phases.
#
# MovementState ::= SEQUENCE {
# movementName DescriptiveName OPTIONAL,
# -- uniquely defines movement by name
# -- human readable name for intersection
# -- to be used only in debug mode
# signalGroup SignalGroupID,
# -- the group id is used to map to lists
# -- of lanes (and their descriptions)
# -- which this MovementState data applies to
# -- see comments in the Remarks for usage details
# state-time-speed MovementEventList,
# -- Consisting of sets of movement data with:
# -- a) SignalPhaseState
# -- b) TimeChangeDetails, and
# -- c) AdvisorySpeeds (optional )
# -- Note one or more of the movement events may be for
# -- a future time and that this allows conveying multiple
# -- predictive phase and movement timing for various uses
# -- for the current signal group
# maneuverAssistList ManeuverAssistList OPTIONAL,
# -- This information may also be placed in the
# -- IntersectionState when common information applies to
# -- different lanes in the same way
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-MovementState}} OPTIONAL,
# ...
# }


# DescriptiveName OPTIONAL := IA5String (SIZE(1..63))
# -- often for debug use only
# -- but at times used to name ped crossings
string movement_name
bool movement_name_exists

# SignalGroupID ::= INTEGER (0..255)
# -- The value 0 shall be used when the ID is
# -- not available or known
# -- the value 255 is reserved to indicate a
# -- permanent green movement state
uint8 signal_group

# state-time-speed MovementEventList
j2735_msgs/MovementEventList state_time_speed

j2735_msgs/ManeuverAssistList maneuver_assist_list
bool maneuver_assist_list_exists

# regional #TODO: RegionalExtensions are not yet implemented in asn1c

================================================================================
MSG: j2735_msgs/MovementEventList
#
# MovementEventList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The MovementEventList data frame consists of a list of MovementEvent entries.
#
# MovementEventList ::= SEQUENCE (SIZE(1..16)) OF MovementEvent
#

j2735_msgs/MovementEvent[] movement_event_list

================================================================================
MSG: j2735_msgs/MovementEvent
#
# MovementEvent.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The MovementEvent data frame contains details about a single movement. It is used by the movement state to
# convey one of number of movements (typically occurring over a sequence of times) for a SignalGroupID.
#
# MovementEvent ::= SEQUENCE {
# eventState MovementPhaseState,
# -- Consisting of:
# -- Phase state (the basic 11 states)
# -- Directional, protected, or permissive state
# timing TimeChangeDetails OPTIONAL,
# -- Timing Data in UTC time stamps for event
# -- includes start and min/max end times of phase
# -- confidence and estimated next occurrence
# speeds AdvisorySpeedList OPTIONAL,
# -- various speed advisories for use by
# -- general and specific types of vehicles
# -- supporting green-wave and other flow needs
# -- See Section 11 for converting and translating
# -- speed expressed in mph into units of m/s
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-MovementEvent}} OPTIONAL,
# ...
# }

j2735_msgs/MovementPhaseState event_state

j2735_msgs/TimeChangeDetails timing
bool timing_exists

j2735_msgs/AdvisorySpeedList speeds
bool speeds_exists

#regional #TODO: RegionalExtensions are not yet implemented in asn1c



================================================================================
MSG: j2735_msgs/MovementPhaseState
#
# MovementEvent.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DE_MovementPhaseState data element provides the overall current state of the movement (in many cases a
# signal state), including its core phase state and an indication of whether this state is permissive or protected.
#
# MovementPhaseState ::= ENUMERATED {
# -- Note that based on the regions and the operating mode not every
# -- phase will be used in all transportation modes and that not
# -- every phase will be used in all transportation modes
# unavailable (0),
# -- This state is used for unknown or error
# dark (1),
# -- The signal head is dark (unlit)
# -- Reds
# stop-Then-Proceed (2),
# -- Often called 'flashing red' in US
# -- Driver Action:
# -Stop vehicle at stop line.
# -Do not proceed unless it is safe.
# -- Note that the right to proceed either right or left
# -- it is safe may be contained in the lane description
# -- handle what is called a 'right on red'
# stop-And-Remain (3),
# -- e.g. called 'red light' in US
# -- Driver Action:
# -Stop vehicle at stop line.
# -Do not proceed.
# -- Note that the right to proceed either right or left
# -- it is safe may be contained in the lane description
# -- handle what is called a 'right on red'
# -- Greens
# pre-Movement (4),
# -- Not used in the US, red+yellow partly in EU
# -- Driver Action:
# -Stop vehicle.
# -Prepare to proceed (pending green)
# -(Prepare for transition to green/go)
# permissive-Movement-Allowed (5),
# -- Often called 'permissive green' in US
# -- Driver Action:
# -Proceed with caution,
# -must yield to all conflicting traffic
# -- Conflicting traffic may be present
# -- in the intersection conflict area
# protected-Movement-Allowed (6),
# -- Often called 'protected green' in US
# -- Driver Action:
# -Proceed, tossing caution to the wind,
# -in indicated (allowed) direction.
# -- Yellows / Ambers
# -- The vehicle is not allowed to cross the stop bar if it is possible
# -- to stop without danger.
# permissive-clearance (7),
# -- Often called 'permissive yellow' in US
# -- Driver Action:
# -Prepare to stop.
# -Proceed if unable to stop,
# -Clear Intersection.
# -- Conflicting traffic may be present
# -- in the intersection conflict area
# protected-clearance (8),
# -- Often called 'protected yellow' in US
# -- Driver Action:
# -Prepare to stop.
# -Proceed if unable to stop,
# -in indicated direction (to connected lane)
# -Clear Intersection.
# caution-Conflicting-Traffic (9)
# -- Often called 'flashing yellow' in US
# -- Often used for extended periods of time
# -- Driver Action:
# -Proceed with caution,
# -- Conflicting traffic may be present
# -- in the intersection conflict area
# }
# -- The above number assignments are not used with UPER encoding
# -- and are only to be used with DER or implicit encoding

uint8 movement_phase_state

uint8 UNAVAILABLE=0
uint8 DARK=1
uint8 STOP_THEN_PROCEED=2
uint8 STOP_AND_REMAIN=3
uint8 PRE_MOVEMENT=4
uint8 PERMISSIVE_MOVEMENT_ALLOWED=5
uint8 PROTECTED_MOVEMENT_ALLOWED=6
uint8 PERMISSIVE_CLEARANCE=7
uint8 PROTECTED_CLEARANCE=8
uint8 CAUTION_CONFLICTING_TRAFFIC=9


================================================================================
MSG: j2735_msgs/TimeChangeDetails
#
# TimeChangeDetails.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_TimeChangeDetails data frame conveys details about the timing of a phase within a movement. The core
# data concept expressed is the time stamp (time mark) at which the related phase will change to the next state. This is
# often found in the MinEndTime element, but the other elements may be needed to convey the full concept when adaptive
# timing is employed.
#
#
# TimeChangeDetails ::= SEQUENCE {
# startTime TimeMark OPTIONAL,
# -- When this phase 1st started
# minEndTime TimeMark,
# -- Expected shortest end time
# maxEndTime TimeMark OPTIONAL,
# -- Expected longest end time
# likelyTime TimeMark OPTIONAL,
# -- Best predicted value based on other data
# confidence TimeIntervalConfidence OPTIONAL,
# -- Applies to above time element only
# nextTime TimeMark OPTIONAL
# -- A rough estimate of time when
# -- this phase may next occur again
# -- used to support various ECO driving power
# -- management needs.
# }

# TimeMark ::= INTEGER (0..36001)
# -- Tenths of a second in the current or next hour
# -- In units of 1/10th second from UTC time
# -- A range of 0~36000 covers one hour
# -- The values 35991..35999 are used when a leap second occurs
# -- The value 36000 is used to indicate time >3600 seconds
# -- 36001 is to be used when value undefined or unknown
# -- Note that this is NOT expressed in GPS time
# -- or in local time
uint16 start_time
bool start_time_exists

uint16 min_end_time

uint16 max_end_time
bool max_end_time_exists

uint16 likely_time
bool likely_time_exists

#TimeIntervalConfidence ::= INTEGER (0..15)
uint8 confidence
bool confidence_exists

# TimeMark ::= INTEGER (0..36001)
uint16 next_time
bool next_time_exists


================================================================================
MSG: j2735_msgs/AdvisorySpeedList
#
# AdvisorySpeedList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The AdvisorySpeedList data frame consists of a list of AdvisorySpeed entries.
#
# AdvisorySpeedList ::= SEQUENCE (SIZE(1..16)) OF AdvisorySpeed

j2735_msgs/AdvisorySpeed[] advisory_speed_list
================================================================================
MSG: j2735_msgs/AdvisorySpeed
#
# AdvisorySpeed.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_AdvisorySpeed data frame is used to convey a recommended traveling approach speed to an intersection
# from the message issuer to various travelers and vehicle types. Besides support for various eco-driving applications, this
# allows transmitting recommended speeds for specialty vehicles such as transit buses.
# AdvisorySpeed ::= SEQUENCE {
# type AdvisorySpeedType,
# -- the type of advisory which this is.
# speed SpeedAdvice OPTIONAL,
# -- See Section 11 for converting and translating speed
# -- expressed in mph into units of m/s
# -- This element is optional ONLY when superceded
# -- by the presence of a regional speed element found in
# -- Reg-AdvisorySpeed entry
# confidence SpeedConfidence OPTIONAL,
# -- A confidence value for the above speed
# distance ZoneLength OPTIONAL,
# -- Unit = 1 meter,
# -- The distance indicates the region for which the advised speed
# -- is recommended, it is specified upstream from the stop bar
# -- along the connected egressing lane
# class RestrictionClassID OPTIONAL,
# -- the vehicle types to which it applies
# -- when absent, the AdvisorySpeed applies to
# -- all motor vehicle types
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-AdvisorySpeed}} OPTIONAL,
# ...
# }

j2735_msgs/AdvisorySpeedType type

# SpeedAdvice ::= INTEGER (0..500) OPTIONAL
# This data element represents the recommended velocity of an object, typically a vehicle speed along a roadway,
# expressed in unsigned units of 0.1 meters per second.
#-- LSB units are 0.1 m/s^2
#-- the value 499 shall be used for values at or greater than 49.9 m/s
#-- the value 500 shall be used to indicate that speed is unavailable
float32 speed
float32 SPEED_UNAVAILABLE = 500
bool speed_exists

# SpeedConfidence is an enum already with 0 as unavailable.
j2735_msgs/SpeedConfidence confidence

# ZoneLength ::= INTEGER (0..10000)
# -- Unit = 1 meter, 0 = unknown,
# -- The value 10000 to be used for Distances >=10000 m
# -- (e.g. from known point to another point along a
# -- known path, often against traffic flow direction
# -- when used for measuring queues)
uint16 distance
uint16 DISTANCE_UNKNOWN=0
bool distance_exists

# RestrictionClassID ::= INTEGER (0..255)
uint8 restriction_class_id
bool restriction_class_id_exists

# regional #TODO: RegionalExtensions are not yet implemented in asn1c



================================================================================
MSG: j2735_msgs/AdvisorySpeedType
#
# AdvisorySpeedType.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DE_AdvisorySpeedType data element relates the type of travel to which a given speed refers. This element is
# typically used as part of an AdvisorySpeed data frame for signal phase and timing data.
#
# AdvisorySpeedType ::= ENUMERATED {
# none (0),
# greenwave (1),
# ecoDrive (2),
# transit (3),
# ...
# } -- Note: subject to further growth

uint8 advisory_speed_type

uint8 NONE=0
uint8 GREENWAVE=1
uint8 ECODRIVE=2
uint8 TRANSIT=3

================================================================================
MSG: j2735_msgs/SpeedConfidence
#
# SpeedConfidence.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DE_SpeedConfidence data element is used to provide the 95% confidence level for the currently reported
# value of DE_Speed, taking into account the current calibration and precision of the sensor(s) used to measure and/or
# calculate the value.

# SpeedConfidence ::= ENUMERATED {
# unavailable (0), -- Not Equipped or unavailable
# prec100ms (1), -- 100 meters / sec
# prec10ms(2), -- 10 meters / sec
# prec5ms (3), -- 5 meters / sec
# prec1ms (4), -- 1 meters / sec
# prec0-1ms (5), -- 0.1 meters / sec
# prec0-05ms (6), -- -- 0.05 meters / sec
# prec0-01ms (7) -- -- 0.01 meters / sec
# }

uint8 speed_confidence

uint8 UNAVAILABLE=0
uint8 PREC100MS=1
uint8 PREC10MS=2
uint8 PREC5MS=3
uint8 PREC1MS=4
uint8 PREC0_1MS=5
uint8 PREC0_05MS=6
uint8 PREC0_01MS=7
================================================================================
MSG: j2735_msgs/ManeuverAssistList
# This entry is used directly by one other data structure in this standard, a DF called DF_LaneAttributes <ASN>.
#  In addition, this item may be used by data structures in other ITS standards.
# ManeuverAssistList ::= SEQUENCE (SIZE(1..16)) OF ConnectionManeuverAssist

j2735_msgs/ConnectionManeuverAssist[] connection_maneuver_assist_list

================================================================================
MSG: j2735_msgs/ConnectionManeuverAssist

# The ConnectionManeuverAssist data frame contains information about the the dynamic flow of traffic for the lane(s)
# and maneuvers in question (as determined by the LaneConnectionID). Note that this information can be sent regarding
# any lane-to-lane movement; it need not be limited to the lanes with active (non-red) phases when sent.
#
# ConnectionManeuverAssist ::= SEQUENCE {
# connectionID LaneConnectionID,
# -- the common connectionID used by all lanes to which
# -- this data applies
# -- (this value traces to ConnectsTo entries in lanes)
# -- Expected Clearance Information
# queueLength ZoneLength OPTIONAL,
# -- Unit = 1 meter, 0 = no queue
# -- The distance from the stop line to the back
# -- edge of the last vehicle in the queue,
# -- as measured along the lane center line.
# availableStorageLength ZoneLength OPTIONAL,
# -- Unit = 1 meter, 0 = no space remains
# -- Distance (e.g. beginning from the downstream
# -- stop-line up to a given distance) with a high
# -- probability for successfully executing the
# -- connecting maneuver between the two lanes
# -- during the current cycle.
# -- Used for enhancing the awareness of vehicles
# -- to anticipate if they can pass the stop line
# -- of the lane. Used for optimizing the green wave,
# -- due to knowledge of vehicles waiting in front
# -- of a red light (downstream).
# -- The element nextTime in TimeChangeDetails
# -- in the containing data frame contains the next
# -- timemark at which an active phase is expected,
# -- a form of storage flush interval.
# waitOnStop WaitOnStopline OPTIONAL,
# -- If "true", the vehicles on this specific connecting
# -- maneuver have to stop on the stop-line and not
# -- to enter the collision area
# pedBicycleDetect PedestrianBicycleDetect OPTIONAL,
# -- true if ANY ped or bicycles are detected crossing
# -- the above lanes. Set to false ONLY if there is a
# -- high certainty that there are none present,
# -- otherwise element is not sent.
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-ConnectionManeuverAssist}} OPTIONAL,
# ...
# }

# LaneConnectionID ::= INTEGER (0..255)
uint8 connection_id

# ZoneLength ::= INTEGER (0..10000)
# -- Unit = 1 meter, 0 = unknown,
# -- The value 10000 to be used for Distances >=10000 m
# -- (e.g. from known point to another point along a
# -- known path, often against traffic flow direction
# -- when used for measuring queues)
uint16 queue_length
bool queue_length_exists

# ZoneLength ::= INTEGER (0..10000)
uint16 available_storage_length
bool available_storage_length_exists

# WaitOnStopline ::= BOOLEAN --- True or False
# -- If "true", the vehicles on this specific connecting
# -- maneuver have to stop on the stop-line
# -- and not to enter the collision area
bool wait_on_stop
bool wait_on_stop_exists

# PedestrianBicycleDetect ::= BOOLEAN
# -- true if ANY Pedestrians or Bicyclists are
# -- detected crossing the target lane or lanes
bool ped_bicycle_detect
bool ped_bicycle_detect_exists

# regional #TODO: RegionalExtensions are not yet implemented in asn1c"""
  __slots__ = ['intersection_state_list']
  _slot_types = ['j2735_msgs/IntersectionState[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       intersection_state_list

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(IntersectionStateList, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.intersection_state_list is None:
        self.intersection_state_list = []
    else:
      self.intersection_state_list = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.intersection_state_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.intersection_state_list:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.name_exists
        buff.write(_get_struct_B().pack(_x))
        _v1 = val1.id
        _x = _v1
        buff.write(_get_struct_HBH().pack(_x.region, _x.region_exists, _x.id))
        _x = val1.revision
        buff.write(_get_struct_B().pack(_x))
        _v2 = val1.status
        _x = _v2.intersection_status_object
        buff.write(_get_struct_H().pack(_x))
        _x = val1
        buff.write(_get_struct_IBIB().pack(_x.moy, _x.moy_exists, _x.time_stamp, _x.time_stamp_exists))
        _v3 = val1.enabled_lanes
        length = len(_v3.lane_id_list)
        buff.write(_struct_I.pack(length))
        pattern = '<%sH'%length
        buff.write(struct.Struct(pattern).pack(*_v3.lane_id_list))
        _x = val1.enabled_lanes_exists
        buff.write(_get_struct_B().pack(_x))
        _v4 = val1.states
        length = len(_v4.movement_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v4.movement_list:
          _x = val3.movement_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2B().pack(_x.movement_name_exists, _x.signal_group))
          _v5 = val3.state_time_speed
          length = len(_v5.movement_event_list)
          buff.write(_struct_I.pack(length))
          for val5 in _v5.movement_event_list:
            _v6 = val5.event_state
            _x = _v6.movement_phase_state
            buff.write(_get_struct_B().pack(_x))
            _v7 = val5.timing
            _x = _v7
            buff.write(_get_struct_HB2HBH3BHB().pack(_x.start_time, _x.start_time_exists, _x.min_end_time, _x.max_end_time, _x.max_end_time_exists, _x.likely_time, _x.likely_time_exists, _x.confidence, _x.confidence_exists, _x.next_time, _x.next_time_exists))
            _x = val5.timing_exists
            buff.write(_get_struct_B().pack(_x))
            _v8 = val5.speeds
            length = len(_v8.advisory_speed_list)
            buff.write(_struct_I.pack(length))
            for val7 in _v8.advisory_speed_list:
              _v9 = val7.type
              _x = _v9.advisory_speed_type
              buff.write(_get_struct_B().pack(_x))
              _x = val7
              buff.write(_get_struct_fB().pack(_x.speed, _x.speed_exists))
              _v10 = val7.confidence
              _x = _v10.speed_confidence
              buff.write(_get_struct_B().pack(_x))
              _x = val7
              buff.write(_get_struct_H3B().pack(_x.distance, _x.distance_exists, _x.restriction_class_id, _x.restriction_class_id_exists))
            _x = val5.speeds_exists
            buff.write(_get_struct_B().pack(_x))
          _v11 = val3.maneuver_assist_list
          length = len(_v11.connection_maneuver_assist_list)
          buff.write(_struct_I.pack(length))
          for val5 in _v11.connection_maneuver_assist_list:
            _x = val5
            buff.write(_get_struct_BHBH5B().pack(_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists))
          _x = val3.maneuver_assist_list_exists
          buff.write(_get_struct_B().pack(_x))
        _v12 = val1.maneuever_assist_list
        length = len(_v12.connection_maneuver_assist_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v12.connection_maneuver_assist_list:
          _x = val3
          buff.write(_get_struct_BHBH5B().pack(_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists))
        _x = val1.maneuever_assist_list_exists
        buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.intersection_state_list is None:
        self.intersection_state_list = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.intersection_state_list = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.IntersectionState()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        start = end
        end += 1
        (val1.name_exists,) = _get_struct_B().unpack(str[start:end])
        val1.name_exists = bool(val1.name_exists)
        _v13 = val1.id
        _x = _v13
        start = end
        end += 5
        (_x.region, _x.region_exists, _x.id,) = _get_struct_HBH().unpack(str[start:end])
        _v13.region_exists = bool(_v13.region_exists)
        start = end
        end += 1
        (val1.revision,) = _get_struct_B().unpack(str[start:end])
        _v14 = val1.status
        start = end
        end += 2
        (_v14.intersection_status_object,) = _get_struct_H().unpack(str[start:end])
        _x = val1
        start = end
        end += 10
        (_x.moy, _x.moy_exists, _x.time_stamp, _x.time_stamp_exists,) = _get_struct_IBIB().unpack(str[start:end])
        val1.moy_exists = bool(val1.moy_exists)
        val1.time_stamp_exists = bool(val1.time_stamp_exists)
        _v15 = val1.enabled_lanes
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sH'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v15.lane_id_list = s.unpack(str[start:end])
        start = end
        end += 1
        (val1.enabled_lanes_exists,) = _get_struct_B().unpack(str[start:end])
        val1.enabled_lanes_exists = bool(val1.enabled_lanes_exists)
        _v16 = val1.states
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v16.movement_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.MovementState()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.movement_name = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.movement_name = str[start:end]
          _x = val3
          start = end
          end += 2
          (_x.movement_name_exists, _x.signal_group,) = _get_struct_2B().unpack(str[start:end])
          val3.movement_name_exists = bool(val3.movement_name_exists)
          _v17 = val3.state_time_speed
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v17.movement_event_list = []
          for i in range(0, length):
            val5 = j2735_msgs.msg.MovementEvent()
            _v18 = val5.event_state
            start = end
            end += 1
            (_v18.movement_phase_state,) = _get_struct_B().unpack(str[start:end])
            _v19 = val5.timing
            _x = _v19
            start = end
            end += 16
            (_x.start_time, _x.start_time_exists, _x.min_end_time, _x.max_end_time, _x.max_end_time_exists, _x.likely_time, _x.likely_time_exists, _x.confidence, _x.confidence_exists, _x.next_time, _x.next_time_exists,) = _get_struct_HB2HBH3BHB().unpack(str[start:end])
            _v19.start_time_exists = bool(_v19.start_time_exists)
            _v19.max_end_time_exists = bool(_v19.max_end_time_exists)
            _v19.likely_time_exists = bool(_v19.likely_time_exists)
            _v19.confidence_exists = bool(_v19.confidence_exists)
            _v19.next_time_exists = bool(_v19.next_time_exists)
            start = end
            end += 1
            (val5.timing_exists,) = _get_struct_B().unpack(str[start:end])
            val5.timing_exists = bool(val5.timing_exists)
            _v20 = val5.speeds
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v20.advisory_speed_list = []
            for i in range(0, length):
              val7 = j2735_msgs.msg.AdvisorySpeed()
              _v21 = val7.type
              start = end
              end += 1
              (_v21.advisory_speed_type,) = _get_struct_B().unpack(str[start:end])
              _x = val7
              start = end
              end += 5
              (_x.speed, _x.speed_exists,) = _get_struct_fB().unpack(str[start:end])
              val7.speed_exists = bool(val7.speed_exists)
              _v22 = val7.confidence
              start = end
              end += 1
              (_v22.speed_confidence,) = _get_struct_B().unpack(str[start:end])
              _x = val7
              start = end
              end += 5
              (_x.distance, _x.distance_exists, _x.restriction_class_id, _x.restriction_class_id_exists,) = _get_struct_H3B().unpack(str[start:end])
              val7.distance_exists = bool(val7.distance_exists)
              val7.restriction_class_id_exists = bool(val7.restriction_class_id_exists)
              _v20.advisory_speed_list.append(val7)
            start = end
            end += 1
            (val5.speeds_exists,) = _get_struct_B().unpack(str[start:end])
            val5.speeds_exists = bool(val5.speeds_exists)
            _v17.movement_event_list.append(val5)
          _v23 = val3.maneuver_assist_list
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v23.connection_maneuver_assist_list = []
          for i in range(0, length):
            val5 = j2735_msgs.msg.ConnectionManeuverAssist()
            _x = val5
            start = end
            end += 11
            (_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists,) = _get_struct_BHBH5B().unpack(str[start:end])
            val5.queue_length_exists = bool(val5.queue_length_exists)
            val5.available_storage_length_exists = bool(val5.available_storage_length_exists)
            val5.wait_on_stop = bool(val5.wait_on_stop)
            val5.wait_on_stop_exists = bool(val5.wait_on_stop_exists)
            val5.ped_bicycle_detect = bool(val5.ped_bicycle_detect)
            val5.ped_bicycle_detect_exists = bool(val5.ped_bicycle_detect_exists)
            _v23.connection_maneuver_assist_list.append(val5)
          start = end
          end += 1
          (val3.maneuver_assist_list_exists,) = _get_struct_B().unpack(str[start:end])
          val3.maneuver_assist_list_exists = bool(val3.maneuver_assist_list_exists)
          _v16.movement_list.append(val3)
        _v24 = val1.maneuever_assist_list
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v24.connection_maneuver_assist_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.ConnectionManeuverAssist()
          _x = val3
          start = end
          end += 11
          (_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists,) = _get_struct_BHBH5B().unpack(str[start:end])
          val3.queue_length_exists = bool(val3.queue_length_exists)
          val3.available_storage_length_exists = bool(val3.available_storage_length_exists)
          val3.wait_on_stop = bool(val3.wait_on_stop)
          val3.wait_on_stop_exists = bool(val3.wait_on_stop_exists)
          val3.ped_bicycle_detect = bool(val3.ped_bicycle_detect)
          val3.ped_bicycle_detect_exists = bool(val3.ped_bicycle_detect_exists)
          _v24.connection_maneuver_assist_list.append(val3)
        start = end
        end += 1
        (val1.maneuever_assist_list_exists,) = _get_struct_B().unpack(str[start:end])
        val1.maneuever_assist_list_exists = bool(val1.maneuever_assist_list_exists)
        self.intersection_state_list.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.intersection_state_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.intersection_state_list:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.name_exists
        buff.write(_get_struct_B().pack(_x))
        _v25 = val1.id
        _x = _v25
        buff.write(_get_struct_HBH().pack(_x.region, _x.region_exists, _x.id))
        _x = val1.revision
        buff.write(_get_struct_B().pack(_x))
        _v26 = val1.status
        _x = _v26.intersection_status_object
        buff.write(_get_struct_H().pack(_x))
        _x = val1
        buff.write(_get_struct_IBIB().pack(_x.moy, _x.moy_exists, _x.time_stamp, _x.time_stamp_exists))
        _v27 = val1.enabled_lanes
        length = len(_v27.lane_id_list)
        buff.write(_struct_I.pack(length))
        pattern = '<%sH'%length
        buff.write(_v27.lane_id_list.tostring())
        _x = val1.enabled_lanes_exists
        buff.write(_get_struct_B().pack(_x))
        _v28 = val1.states
        length = len(_v28.movement_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v28.movement_list:
          _x = val3.movement_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_2B().pack(_x.movement_name_exists, _x.signal_group))
          _v29 = val3.state_time_speed
          length = len(_v29.movement_event_list)
          buff.write(_struct_I.pack(length))
          for val5 in _v29.movement_event_list:
            _v30 = val5.event_state
            _x = _v30.movement_phase_state
            buff.write(_get_struct_B().pack(_x))
            _v31 = val5.timing
            _x = _v31
            buff.write(_get_struct_HB2HBH3BHB().pack(_x.start_time, _x.start_time_exists, _x.min_end_time, _x.max_end_time, _x.max_end_time_exists, _x.likely_time, _x.likely_time_exists, _x.confidence, _x.confidence_exists, _x.next_time, _x.next_time_exists))
            _x = val5.timing_exists
            buff.write(_get_struct_B().pack(_x))
            _v32 = val5.speeds
            length = len(_v32.advisory_speed_list)
            buff.write(_struct_I.pack(length))
            for val7 in _v32.advisory_speed_list:
              _v33 = val7.type
              _x = _v33.advisory_speed_type
              buff.write(_get_struct_B().pack(_x))
              _x = val7
              buff.write(_get_struct_fB().pack(_x.speed, _x.speed_exists))
              _v34 = val7.confidence
              _x = _v34.speed_confidence
              buff.write(_get_struct_B().pack(_x))
              _x = val7
              buff.write(_get_struct_H3B().pack(_x.distance, _x.distance_exists, _x.restriction_class_id, _x.restriction_class_id_exists))
            _x = val5.speeds_exists
            buff.write(_get_struct_B().pack(_x))
          _v35 = val3.maneuver_assist_list
          length = len(_v35.connection_maneuver_assist_list)
          buff.write(_struct_I.pack(length))
          for val5 in _v35.connection_maneuver_assist_list:
            _x = val5
            buff.write(_get_struct_BHBH5B().pack(_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists))
          _x = val3.maneuver_assist_list_exists
          buff.write(_get_struct_B().pack(_x))
        _v36 = val1.maneuever_assist_list
        length = len(_v36.connection_maneuver_assist_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v36.connection_maneuver_assist_list:
          _x = val3
          buff.write(_get_struct_BHBH5B().pack(_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists))
        _x = val1.maneuever_assist_list_exists
        buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.intersection_state_list is None:
        self.intersection_state_list = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.intersection_state_list = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.IntersectionState()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        start = end
        end += 1
        (val1.name_exists,) = _get_struct_B().unpack(str[start:end])
        val1.name_exists = bool(val1.name_exists)
        _v37 = val1.id
        _x = _v37
        start = end
        end += 5
        (_x.region, _x.region_exists, _x.id,) = _get_struct_HBH().unpack(str[start:end])
        _v37.region_exists = bool(_v37.region_exists)
        start = end
        end += 1
        (val1.revision,) = _get_struct_B().unpack(str[start:end])
        _v38 = val1.status
        start = end
        end += 2
        (_v38.intersection_status_object,) = _get_struct_H().unpack(str[start:end])
        _x = val1
        start = end
        end += 10
        (_x.moy, _x.moy_exists, _x.time_stamp, _x.time_stamp_exists,) = _get_struct_IBIB().unpack(str[start:end])
        val1.moy_exists = bool(val1.moy_exists)
        val1.time_stamp_exists = bool(val1.time_stamp_exists)
        _v39 = val1.enabled_lanes
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sH'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v39.lane_id_list = numpy.frombuffer(str[start:end], dtype=numpy.uint16, count=length)
        start = end
        end += 1
        (val1.enabled_lanes_exists,) = _get_struct_B().unpack(str[start:end])
        val1.enabled_lanes_exists = bool(val1.enabled_lanes_exists)
        _v40 = val1.states
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v40.movement_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.MovementState()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.movement_name = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.movement_name = str[start:end]
          _x = val3
          start = end
          end += 2
          (_x.movement_name_exists, _x.signal_group,) = _get_struct_2B().unpack(str[start:end])
          val3.movement_name_exists = bool(val3.movement_name_exists)
          _v41 = val3.state_time_speed
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v41.movement_event_list = []
          for i in range(0, length):
            val5 = j2735_msgs.msg.MovementEvent()
            _v42 = val5.event_state
            start = end
            end += 1
            (_v42.movement_phase_state,) = _get_struct_B().unpack(str[start:end])
            _v43 = val5.timing
            _x = _v43
            start = end
            end += 16
            (_x.start_time, _x.start_time_exists, _x.min_end_time, _x.max_end_time, _x.max_end_time_exists, _x.likely_time, _x.likely_time_exists, _x.confidence, _x.confidence_exists, _x.next_time, _x.next_time_exists,) = _get_struct_HB2HBH3BHB().unpack(str[start:end])
            _v43.start_time_exists = bool(_v43.start_time_exists)
            _v43.max_end_time_exists = bool(_v43.max_end_time_exists)
            _v43.likely_time_exists = bool(_v43.likely_time_exists)
            _v43.confidence_exists = bool(_v43.confidence_exists)
            _v43.next_time_exists = bool(_v43.next_time_exists)
            start = end
            end += 1
            (val5.timing_exists,) = _get_struct_B().unpack(str[start:end])
            val5.timing_exists = bool(val5.timing_exists)
            _v44 = val5.speeds
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v44.advisory_speed_list = []
            for i in range(0, length):
              val7 = j2735_msgs.msg.AdvisorySpeed()
              _v45 = val7.type
              start = end
              end += 1
              (_v45.advisory_speed_type,) = _get_struct_B().unpack(str[start:end])
              _x = val7
              start = end
              end += 5
              (_x.speed, _x.speed_exists,) = _get_struct_fB().unpack(str[start:end])
              val7.speed_exists = bool(val7.speed_exists)
              _v46 = val7.confidence
              start = end
              end += 1
              (_v46.speed_confidence,) = _get_struct_B().unpack(str[start:end])
              _x = val7
              start = end
              end += 5
              (_x.distance, _x.distance_exists, _x.restriction_class_id, _x.restriction_class_id_exists,) = _get_struct_H3B().unpack(str[start:end])
              val7.distance_exists = bool(val7.distance_exists)
              val7.restriction_class_id_exists = bool(val7.restriction_class_id_exists)
              _v44.advisory_speed_list.append(val7)
            start = end
            end += 1
            (val5.speeds_exists,) = _get_struct_B().unpack(str[start:end])
            val5.speeds_exists = bool(val5.speeds_exists)
            _v41.movement_event_list.append(val5)
          _v47 = val3.maneuver_assist_list
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v47.connection_maneuver_assist_list = []
          for i in range(0, length):
            val5 = j2735_msgs.msg.ConnectionManeuverAssist()
            _x = val5
            start = end
            end += 11
            (_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists,) = _get_struct_BHBH5B().unpack(str[start:end])
            val5.queue_length_exists = bool(val5.queue_length_exists)
            val5.available_storage_length_exists = bool(val5.available_storage_length_exists)
            val5.wait_on_stop = bool(val5.wait_on_stop)
            val5.wait_on_stop_exists = bool(val5.wait_on_stop_exists)
            val5.ped_bicycle_detect = bool(val5.ped_bicycle_detect)
            val5.ped_bicycle_detect_exists = bool(val5.ped_bicycle_detect_exists)
            _v47.connection_maneuver_assist_list.append(val5)
          start = end
          end += 1
          (val3.maneuver_assist_list_exists,) = _get_struct_B().unpack(str[start:end])
          val3.maneuver_assist_list_exists = bool(val3.maneuver_assist_list_exists)
          _v40.movement_list.append(val3)
        _v48 = val1.maneuever_assist_list
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v48.connection_maneuver_assist_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.ConnectionManeuverAssist()
          _x = val3
          start = end
          end += 11
          (_x.connection_id, _x.queue_length, _x.queue_length_exists, _x.available_storage_length, _x.available_storage_length_exists, _x.wait_on_stop, _x.wait_on_stop_exists, _x.ped_bicycle_detect, _x.ped_bicycle_detect_exists,) = _get_struct_BHBH5B().unpack(str[start:end])
          val3.queue_length_exists = bool(val3.queue_length_exists)
          val3.available_storage_length_exists = bool(val3.available_storage_length_exists)
          val3.wait_on_stop = bool(val3.wait_on_stop)
          val3.wait_on_stop_exists = bool(val3.wait_on_stop_exists)
          val3.ped_bicycle_detect = bool(val3.ped_bicycle_detect)
          val3.ped_bicycle_detect_exists = bool(val3.ped_bicycle_detect_exists)
          _v48.connection_maneuver_assist_list.append(val3)
        start = end
        end += 1
        (val1.maneuever_assist_list_exists,) = _get_struct_B().unpack(str[start:end])
        val1.maneuever_assist_list_exists = bool(val1.maneuever_assist_list_exists)
        self.intersection_state_list.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2B = None
def _get_struct_2B():
    global _struct_2B
    if _struct_2B is None:
        _struct_2B = struct.Struct("<2B")
    return _struct_2B
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_BHBH5B = None
def _get_struct_BHBH5B():
    global _struct_BHBH5B
    if _struct_BHBH5B is None:
        _struct_BHBH5B = struct.Struct("<BHBH5B")
    return _struct_BHBH5B
_struct_H = None
def _get_struct_H():
    global _struct_H
    if _struct_H is None:
        _struct_H = struct.Struct("<H")
    return _struct_H
_struct_H3B = None
def _get_struct_H3B():
    global _struct_H3B
    if _struct_H3B is None:
        _struct_H3B = struct.Struct("<H3B")
    return _struct_H3B
_struct_HB2HBH3BHB = None
def _get_struct_HB2HBH3BHB():
    global _struct_HB2HBH3BHB
    if _struct_HB2HBH3BHB is None:
        _struct_HB2HBH3BHB = struct.Struct("<HB2HBH3BHB")
    return _struct_HB2HBH3BHB
_struct_HBH = None
def _get_struct_HBH():
    global _struct_HBH
    if _struct_HBH is None:
        _struct_HBH = struct.Struct("<HBH")
    return _struct_HBH
_struct_IBIB = None
def _get_struct_IBIB():
    global _struct_IBIB
    if _struct_IBIB is None:
        _struct_IBIB = struct.Struct("<IBIB")
    return _struct_IBIB
_struct_fB = None
def _get_struct_fB():
    global _struct_fB
    if _struct_fB is None:
        _struct_fB = struct.Struct("<fB")
    return _struct_fB
