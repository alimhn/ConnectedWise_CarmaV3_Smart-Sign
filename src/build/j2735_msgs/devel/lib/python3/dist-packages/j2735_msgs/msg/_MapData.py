# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from j2735_msgs/MapData.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import j2735_msgs.msg
import std_msgs.msg

class MapData(genpy.Message):
  _md5sum = "4a884ffcbb1d61cacd2b7304877db10b"
  _type = "j2735_msgs/MapData"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """#
# MapData.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# Contains critical core elements deemed to be needed with every MapData Message
# The MapData message is used to convey many types of geographic road information.
# At the current time its primary use is to convey one or more intersection lane geometry maps within a single message.

std_msgs/Header header

#MinuteOfTheYear OPTIONAL ::= INTEGER (0..527040)
# -- The value 527040 shall be used for invalid
uint32 time_stamp
bool time_stamp_exists

#MsgCount ::= INTEGER (0..127)
uint8 msg_issue_revision

#LayerType OPTIONAL :: = ENUMERATED
j2735_msgs/LayerType layer_type

#LayerID OPTIONAL ::= INTEGER (0..100)
uint8 layer_id
bool layer_id_exists

#IntersectionGeometryList OPTIONAL ::= SEQUENCE (SIZE(1..32)) OF IntersectionGeometry
j2735_msgs/IntersectionGeometry[] intersections
bool intersections_exists

# road_segments RoadSegmentList OPTIONAL,
# -- All roadway descriptions
j2735_msgs/RoadSegmentList road_segments
bool road_segments_exists

#DataParameters OPTIONAL,
j2735_msgs/DataParameters data_parameters
bool data_parameters_exists

#RestrictionClassList OPTIONAL,
j2735_msgs/RestrictionClassList restriction_list
bool restriction_list_exists

#RegionalExtension { SEQUENCE (SIZE(1..4)) OF {REGION.Reg-MapData}} OPTIONAL} OPTIONAL
# regional #TODO: RegionalExtensions are not yet implemented in asn1c

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: j2735_msgs/LayerType
# LayerType.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# Data element used to uniquely identify the type of information to be found in a layer of geographic map fragment
# such as an intersection.
#

uint8 layer_type

# LayerType ::= ENUMERATED {
# none,
# mixedContent, -- two or more of the below types
# generalMapData,
# intersectionData,
# curveData,
# roadwaySectionData,
# parkingAreaData,
# sharedLaneData,
# ...
# }

# enumeration values for plan type:
uint8       NONE = 0
uint8       MIXED_CONTENT = 1
uint8       GENERAL_MAP_DATA = 2
uint8       INTERSECTION_DATA = 3
uint8       CURVE_DATA = 4
uint8       ROADWAY_SECTION_DATA = 5
uint8       PARKING_AREA_DATA = 6
uint8       SHARED_LANE_DATA = 7
================================================================================
MSG: j2735_msgs/IntersectionGeometry
#
# IntersectionGeometry.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# A complete description of an intersection's roadway geometry and its allowed navigational paths
# (independent of any additional regulatory restrictions that may apply over time or from user classification).

# IntersectionGeometry ::= SEQUENCE {
# name DescriptiveName OPTIONAL ::= IA5String (SIZE(1..63))
# -- For debug use only
string name
bool name_exists

# id IntersectionReferenceID,
# -- A globally unique value set,
# -- consisting of a regionID and
# -- intersection ID assignment
j2735_msgs/IntersectionReferenceID id

# revision MsgCount  ::= INTEGER (0..127)
# -- Required default values about lane descriptions follow
uint8 revision

# refPoint Position3D, -- The reference from which subsequent
# -- data points are offset until a new
# -- point is used.
j2735_msgs/Position3D ref_point

# laneWidth LaneWidth OPTIONAL ::= INTEGER (0..32767) -- units of 1 cm
# -- Reference width used by all subsequent
# -- lanes unless a new width is given
uint16 lane_width
bool lane_width_exists

# speedLimits SpeedLimitList OPTIONAL
# -- Reference regulatory speed limits
# -- used by all subsequent
# -- lanes unless a new speed is given
# -- See Section 11 for converting and
# -- translating speed expressed in mph
# -- into units of m/s
# -- Complete details regarding each lane type in this intersection
j2735_msgs/SpeedLimitList speed_limits
bool speed_limits_exists

# laneSet LaneList,
# -- Data about one or more lanes
# -- (all lane data is found here)
# -- Data describing how to use and request preemption and
# -- priority services from this intersection (if supported)
j2735_msgs/LaneList lane_set

# -- NOTE Additonal data may be added in the next release of the
# -- standard at this point to handle this concept
# preemptPriorityData PreemptPriorityList OPTIONAL,
# -- data about one or more regional
# -- preempt or priority zones
j2735_msgs/PreemptPriorityList preempt_priority_data
bool preempt_priority_data_exists

#TODO: RegionalExtensions are not yet implemented in asn1c
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-IntersectionGeometry}} OPTIONAL,
# ...
# }

================================================================================
MSG: j2735_msgs/IntersectionReferenceID
#
# IntersectionReferenceID.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The IntersectionReferenceID data frame conveys the combination of an optional RoadRegulatorID and of an
# IntersectionID that is unique within that region. When the RoadRegulatorID is present the IntersectionReferenceID is
# guaranteed to be globally unique.

# region RoadRegulatorID OPTIONAL ::= INTEGER (0..65535)
# -- a globally unique regional assignment value
# -- typical assigned to a regional DOT authority
# -- the value zero shall be used for testing needs
# 0 is a J2735 value for testing needs, and carma can use it to indicate optional field was not set or unavailable.
uint16 region
uint16 REGION_UNAVAILABLE=0
bool region_exists

# id IntersectionID ::= INTEGER (0..65535)
# -- a unique mapping to the intersection
# -- in question within the above region of use
uint16 id

================================================================================
MSG: j2735_msgs/Position3D
#
# Position3D.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
# Provides a precise location in the WGS-84 coordinate system, from which short offsets may be used
# to create additional data using a flat earth projection centered on this location.

# Position3D ::= SEQUENCE {

# lat Latitude, -- in 1/10th micro degrees
# Latitude ::= INTEGER (-900000000..900000001)
#  -- LSB = 1/10 micro degree
#  -- Providing a range of plus-minus 90 degrees
#  -- Convert to degree with factor 0.0000001 when field is used
float64 latitude

float64 LATITUDE_UNAVAILABLE = 90.0000001
float64 LATITUDE_MAX = 90.0
float64 LATITUDE_MIN = -90.0

# long Longitude, -- in 1/10th micro degrees
# Longitude ::= INTEGER (-1799999999..1800000001)
#  -- LSB = 1/10 micro degree
#  -- Providing a range of plus-minus 180 degrees
#  -- Convert to degree with factor 0.0000001 when field is used
float64 longitude

float64 LONGITUDE_UNAVAILABLE = 180.0000001
float64 LONGITUDE_MAX = 180.0
float64 LONGITUDE_MIN = -179.9999999

# elevation Elevation OPTIONAL, -- in 10 cm units
# Elevation ::= INTEGER (-4096..61439)
#  -- In units of 10 cm steps above or below the reference ellipsoid
#  -- Providing a range of -409.5 to + 6143.9 meters
#  -- The value -4096 shall be used when Unknown is to be sent
#  -- Convert to meter with factor 0.1 when field is used
float32 elevation
bool elevation_exists

float32 ELEVATION_UNAVAILABLE = -409.6
float32 ELEVATION_MAX = 6143.9
float32 ELEVATION_MIN = -409.5

#TODO: RegionalExtensions are not yet implemented in asn1c
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-Position3D}} OPTIONAL,

================================================================================
MSG: j2735_msgs/SpeedLimitList
#
# SpeedLimitList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# SpeedLimitList ::= SEQUENCE (SIZE(1..9)) OF RegulatorySpeedLimit

#A list of RegulatorySpeedLimit
j2735_msgs/RegulatorySpeedLimit[] speed_limits
================================================================================
MSG: j2735_msgs/RegulatorySpeedLimit
#
# RegulatorySpeedLimit.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
# Used to convey a regulatory speed about a lane, lanes, or roadway segment.

# RegulatorySpeedLimit ::= SEQUENCE {
# type SpeedLimitType,
# -- The type of regulatory speed which follows
j2735_msgs/SpeedLimitType type

# speed Velocity
# Velocity ::= INTEGER (0..8191) -- Units of 0.02 m/s
#-- The value 8191 indicates that velocity is unavailable
float64 speed
================================================================================
MSG: j2735_msgs/SpeedLimitType
# SpeedLimitType.msg
#
# The SpeedLimitType data element relates the type of speed limit to which a given speed refers.
#
# SpeedLimitType ::= ENUMERATED {
#
# unknown, -- Speed limit type not available
# maxSpeedInSchoolZone, -- Only sent when the limit is active
# maxSpeedInSchoolZoneWhenChildrenArePresent, -- Sent at any time
# maxSpeedInConstructionZone, -- Used for work zones, incident zones, etc. where a reduced speed is present
#
# vehicleMinSpeed,
# vehicleMaxSpeed, -- Regulatory speed limit for general traffic
# vehicleNightMaxSpeed,
#
# truckMinSpeed,
# truckMaxSpeed,
# truckNightMaxSpeed,
#
# vehiclesWithTrailersMinSpeed,
# vehiclesWithTrailersMaxSpeed,
# vehiclesWithTrailersNightMaxSpeed,
# ...
# }

uint8 speed_limit_type

uint8 UNKNOWN=0
uint8 MAXSPEEDINSCHOOLZONE=1
uint8 MAXSPEEDINSCHOOLZONEWHENCHILDRENAREPRESENT=2
uint8 MAXSPEEDINCONSTRUCTIONZONE=3
uint8 VEHICLEMINSPEED=4
uint8 VEHICLEMAXSPEED=5
uint8 VEHICLENIGHTMAXSPEED=6
uint8 TRUCKMINSPEED=7
uint8 TRUCKMAXSPEED=8
uint8 TRUCKNIGHTMAXSPEED=9
uint8 VEHICLESWITHTRAILERSMINSPEED=10
uint8 VEHICLESWITHTRAILERSMAXSPEED=11
uint8 VEHICLESWITHTRAILERSNIGHTMAXSPEED=12
================================================================================
MSG: j2735_msgs/LaneList
#
# LaneList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The LaneList data frame consists of a list of GenericLane entries.
# LaneList ::= SEQUENCE (SIZE(1..255)) OF GenericLane
#

j2735_msgs/GenericLane[] lane_list

================================================================================
MSG: j2735_msgs/GenericLane
#
# GenericLane.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# GenericLane ::= SEQUENCE {
#
# laneID LaneID ::= INTEGER (0..255)
# -- The unique ID number assigned
# -- to this lane object
uint8 lane_id

# name DescriptiveName OPTIONAL := IA5String (SIZE(1..63))
# -- often for debug use only
# -- but at times used to name ped crossings
string name
bool name_exists

# ingressApproach ApproachID OPTIONAL, -- inbound
# ApproachID ::= INTEGER (0..15)
uint8 ingress_approach
bool ingress_approach_exists

# egressApproach ApproachID OPTIONAL, -- outbound
# -- Approach IDs to which this lane belongs
uint8 egress_approach
bool egress_approach_exists

# laneAttributes LaneAttributes,
# -- All Attribute information about
# -- the basic selected lane type
# -- Directions of use, Geometric co-sharing
# -- and Type Specific Attributes
# -- These Attributes are 'lane - global' that is,
# -- they are true for the entire length of the lane
j2735_msgs/LaneAttributes lane_attributes

# maneuvers AllowedManeuvers OPTIONAL,
# -- the permitted maneuvers for this lane
j2735_msgs/AllowedManeuvers maneuvers
bool maneuvers_exists

# nodeList NodeListXY,
# -- Lane spatial path information as well as
# -- various Attribute information along the node path
# -- Attributes found here are more general and may
# -- come and go over the length of the lane.
j2735_msgs/NodeListXY node_list

# connectsTo ConnectsToList OPTIONAL,
# -- a list of other lanes and their signal group IDs
# -- each connecting lane and its signal group ID
# -- is given, therefore this element provides the
# -- information formerly in "signalGroups" in prior
# -- editions.
j2735_msgs/ConnectsToList connects_to
bool connects_to_exists

# overlays OverlayLaneList OPTIONAL,
# -- A list of any lanes which have spatial paths that
# -- overlay (run on top of, and not simply cross)
# -- the path of this lane when used
j2735_msgs/OverlayLaneList overlay_lane_list
bool overlay_lane_list_exists

# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-GenericLane} OPTIONAL,
# ...
# }
================================================================================
MSG: j2735_msgs/LaneAttributes
#
# LaneAttributes.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# directionalUse LaneDirection, -- directions of lane use
j2735_msgs/LaneDirection directional_use

# sharedWith LaneSharing  -- co-users of the lane path
j2735_msgs/LaneSharing shared_with

# laneType LaneTypeAttributes, -- specific lane type data
j2735_msgs/LaneTypeAttributes laneType

# regional RegionalExtension {{REGION.Reg-LaneAttributes}} OPTIONAL
#TODO: RegionalExtensions are not yet implemented in asn1c


================================================================================
MSG: j2735_msgs/LaneDirection
#
# LaneDirection.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The LaneDirection data element is used to denote the allowed direction of travel over a lane object. By convention,
# the lane object is always described from the stop line outwards away from the intersection. Therefore, the ingress
# direction is from the end of the path to the stop line and the egress direction is from the stop line outwards. It should be
# noted that some lane objects are not used for travel and that some lane objects allow bi-directional travel.
#
# LaneDirection ::= BIT STRING {
# -- With bits as defined:
# -- Allowed directions of travel in the lane object
# -- All lanes are described from the stop line outwards
# ingressPath (0),
# -- travel from rear of path to front is allowed
# egressPath (1)
# -- travel from front of path to rear is allowed
# -- Notes: No Travel, i.e. the lane object type does not support travel (medians, curbs, etc.)
# is indicated by not asserting any bit value
# - Bi-Directional Travel (such as a ped crosswalk) is indicated by asserting both of the bits
# } (SIZE (2))

uint8 lane_direction
================================================================================
MSG: j2735_msgs/LaneSharing
#
# LaneSharing.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
#
# LaneSharing ::= BIT STRING {
# -- With bits as defined:
# overlappingLaneDescriptionProvided (0),
# -- Assert when another lane object is present to describe the
# -- path of the overlapping shared lane
# -- this construct is not used for lane objects which simply cross
# multipleLanesTreatedAsOneLane(1),
# -- Assert if the lane object path and width details represents
# -- multiple lanes within it that are not further described
# -- Various modes and type of traffic that may share this lane:
# otherNonMotorizedTrafficTypes (2), -- horse drawn etc.
# individualMotorizedVehicleTraffic (3),
# busVehicleTraffic (4),
# taxiVehicleTraffic (5),
# pedestriansTraffic (6),
# cyclistVehicleTraffic (7),
# trackedVehicleTraffic (8),
# pedestrianTraffic (9)
# } (SIZE (10))
# -- All zeros would indicate 'not shared' and 'not overlapping'

uint16 lane_sharing
================================================================================
MSG: j2735_msgs/LaneTypeAttributes
#
# LaneTypeAttributes.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The Lane Type Attributes data frame is used to hold attribute information specific to a given lane type.
# LaneTypeAttributes ::= CHOICE {
# vehicle LaneAttributes-Vehicle, -- motor vehicle lanes
# crosswalk LaneAttributes-Crosswalk, -- pedestrian crosswalks
# bikeLane LaneAttributes-Bike, -- bike lanes
# sidewalk LaneAttributes-Sidewalk, -- pedestrian sidewalk paths
# median LaneAttributes-Barrier, -- medians & channelization
# striping LaneAttributes-Striping, -- roadway markings
# trackedVehicle LaneAttributes-TrackedVehicle, -- trains and trolleys
# parking LaneAttributes-Parking, -- parking and stopping lanes
# }

uint8 choice
uint8 VEHICLE=0
uint8 CROSSWALK=1
uint8 BIKE_LANE=2
uint8 SIDEWALK=3
uint8 MEDIAN=4
uint8 STRIPING=5
uint8 TRACKED_VEHICLE=6
uint8 PARKING=7

j2735_msgs/LaneAttributesVehicle vehicle
j2735_msgs/LaneAttributesCrosswalk crosswalk
j2735_msgs/LaneAttributesBike bikeLane
j2735_msgs/LaneAttributesSidewalk sidewalk
j2735_msgs/LaneAttributesBarrier median
j2735_msgs/LaneAttributesStriping striping
j2735_msgs/LaneAttributesTrackedVehicle trackedVehicle
j2735_msgs/LaneAttributesParking parking
================================================================================
MSG: j2735_msgs/LaneAttributesVehicle
#
# LaneAttributesVehicle.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# LaneAttributes-Vehicle ::= BIT STRING {
# -- With bits as defined:
# isVehicleRevocableLane (0),
#       -- this lane may be activated or not based
#       -- on the current SPAT message contents
#       -- if not asserted, the lane is ALWAYS present
# isVehicleFlyOverLane (1),
#       -- path of lane is not at grade
# hovLaneUseOnly (2),
# restrictedToBusUse (3),
# restrictedToTaxiUse(4),
# restrictedFromPublicUse (5),
# hasIRbeaconCoverage(6),
# permissionOnRequest(7)
#       -- e.g. to inform about a lane for e-cars
# } (SIZE (8,...))

uint8 lane_attributes_vehicle

uint8 ISVEHICLEREVOCABLELANE=0
uint8 ISVEHICLEFLYOVERLANE=1
uint8 HOVLANEUSEONLY=2
uint8 RESTRICTEDTOBUSUSE=3
uint8 RESTRICTEDTOTAXIUSE=4
uint8 RESTRICTEDFROMPUBLICUSE=5
uint8 HASIRBEACONCOVERAGE=6
uint8 PERMISSIONONREQUEST=7


================================================================================
MSG: j2735_msgs/LaneAttributesCrosswalk
#
# LaneAttributesCrosswalk.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#

# LaneAttributes-Crosswalk ::= BIT STRING {
# 	-- With bits as defined:
# 	-- MUTCD provides no suitable "types" to use here
# 	crosswalkRevocableLane (0),
# 		-- this lane may be activated or not based
# 		-- on the current SPAT message contents
# 		-- if not asserted, the lane is ALWAYS present
# 	bicyleUseAllowed (1),
# 		-- The path allows bicycle traffic,
# 		-- if not set, this mode is prohibited
# 	isXwalkFlyOverLane (2),
# 		-- path of lane is not at grade
# 	fixedCycleTime (3),
# 		-- ped walk phases use preset times
# 		-- i.e. there is not a 'push to cross' button
# 	biDirectionalCycleTimes (4),
# 		-- ped walk phases use different SignalGroupID
# 		-- for each direction. The first SignalGroupID
# 		-- in the first Connection represents 'inbound'
# 		-- flow (the direction of travel towards the first
# 		-- node point) while second SignalGroupID in the
# 		-- next Connection entry represents the 'outbound'
# 		-- flow. And use of RestrictionClassID entries
# 		-- in the Connect follow this same pattern in pairs.
# 	hasPushToWalkButton (5),
# 		-- Has a demand input
# 	audioSupport (6),
# 		-- audio crossing cues present
# 	rfSignalRequestPresent (7),
# 		-- Supports RF push to walk technologies
# 	unsignalizedSegmentsPresent (8)
# 		-- The lane path consists of one of more segments
# 		-- which are not part of a signal group ID
# } (SIZE (16))

uint16  lane_attributes_crosswalk
================================================================================
MSG: j2735_msgs/LaneAttributesBike
#
# LaneAttributesBike.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The LaneAttributes-Bike data element relates specific properties found in a bicycle lane type.
#
# LaneAttributes-Bike ::= BIT STRING {
#	-- With bits as defined:
#	bikeRevocableLane (0),
#		-- this lane may be activated or not based
#		-- on the current SPAT message contents
#		-- if not asserted, the lane is ALWAYS present
#	pedestrianUseAllowed (1),
#		-- The path allows pedestrian traffic,
#		-- if not set, this mode is prohibited
#	isBikeFlyOverLane (2),
#		-- path of lane is not at grade
#	fixedCycleTime (3),
#		-- the phases use preset times
#		-- Bits 7~15 reserved and set to zero
#	} (SIZE (16))

uint16 lane_attributes_bike
================================================================================
MSG: j2735_msgs/LaneAttributesSidewalk
#
# LaneAttributesSidewalk.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The LaneAttributes-Sidewalk data element relates specific properties found in a sidewalk lane type
#
# LaneAttributes-Sidewalk ::= BIT STRING {
# -- With bits as defined:
# sidewalk-RevocableLane (0),
# -- this lane may be activated or not based
# -- on the current SPAT message contents
# -- if not asserted, the lane is ALWAYS present
# bicyleUseAllowed (1),
# -- The path allows bicycle traffic,
# -- if not set, this mode is prohibited
# isSidewalkFlyOverLane (2),
# -- path of lane is not at grade
# walkBikes (3)
# -- bike traffic must dismount and walk
# -- Bits 4~15 reserved and set to zero
# } (SIZE (16))

uint16 lane_attributes_sidewalk
================================================================================
MSG: j2735_msgs/LaneAttributesBarrier
#
# LaneAttributesBarrier.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The LaneAttributes-Barrier data element relates specific properties found in a Barrier
# or Median lane type (a type of lane object used to separate traffic lanes).
#
# LaneAttributes-Barrier ::= BIT STRING {
# -- With bits as defined:
# median-RevocableLane (0),
# -- this lane may be activated or not based
# -- on the current SPAT message contents
# -- if not asserted, the lane is ALWAYS present
# median (1),
# whiteLineHashing (2),
# stripedLines (3),
# doubleStripedLines (4),
# trafficCones (5),
# constructionBarrier(6),
# trafficChannels(7),
# lowCurbs(8),
# highCurbs(9)
# -- Bits 10~15 reserved and set to zero
# } (SIZE (16))

uint16 lane_attributes_barrier
================================================================================
MSG: j2735_msgs/LaneAttributesStriping
#
# LaneAttributesBarrier.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The LaneAttributes-Striping data element relates specific properties found
# in various types of ground striping lane types.
#
# LaneAttributes-Striping ::= BIT STRING {
# -- With bits as defined:
# stripeToConnectingLanesRevocableLane(0),
# -- this lane may be activated or not activated based
# -- on the current SPAT message contents
# -- if not asserted, the lane is ALWAYS present
# stripeDrawOnLeft(1),
# stripeDrawOnRight(2),
# -- which side of lane to mark
# stripeToConnectingLanesLeft(3),
# stripeToConnectingLanesRight(4),
# stripeToConnectingLanesAhead(5)
# -- the stripe type should be
# -- presented to the user visually
# -- to reflect stripes in the
# -- intersection for the type of
# -- movement indicated
# -- Bits 6~15 reserved and set to zero
# } (SIZE (16))

uint16 lane_attributes_striping
================================================================================
MSG: j2735_msgs/LaneAttributesTrackedVehicle
#
# LaneAttributesTrackedVehicle.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The LaneAttributes-Special data element relates specific properties found
# in a tracked vehicle lane types (trolley and train lanes).
# The term "rail vehicle" can be considered synonymous.
# In this case, the term does not relate to vehicle types with tracks or treads.
#
# LaneAttributes-TrackedVehicle ::= BIT STRING {
# -- With bits as defined:
# spec-RevocableLane(0),
# -- this lane may be activated or not based
# -- on the current SPAT message contents
# -- if not asserted, the lane is ALWAYS present
# spec-commuterRailRoadTrack (1),
# spec-lightRailRoadTrack(2),
# spec-heavyRailRoadTrack(3),
# spec-otherRailType(4)
# -- Bits 5~15 reserved and set to zero
# } (SIZE (16))

uint16 lane_attributes_trackedvehicle

================================================================================
MSG: j2735_msgs/LaneAttributesParking
#
# LaneAttributesParking.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The LaneAttributes-Parking data element relates specific properties found in a vehicle parking lane type.
#
# LaneAttributes-Parking ::= BIT STRING {
# -- With bits as defined:
# -- Parking use details, note that detailed restrictions such as
# -- allowed hours are sent by way of ITIS codes in the TIM message
# parkingRevocableLane(0),
# -- this lane may be activated or not based
# -- on the current SPAT message contents
# -- if not asserted, the lane is ALWAYS present
# parallelParkingInUse(1),
# headInParkingInUse(2),
# doNotParkZone(3),
# -- used to denote fire hydrants as well as
# -- short disruptions in a parking zone
# parkingForBusUse(4),
# parkingForTaxiUse(5),
# noPublicParkingUse(6)
# -- private parking, as in front of
# -- private property
# -- Bits 7~15 reserved and set to zero
# } (SIZE (16))

uint16  lane_attributes_parking
================================================================================
MSG: j2735_msgs/AllowedManeuvers
#
# AllowedManeuvers.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# AllowedManeuvers ::= BIT STRING {
# -- With bits as defined:
# -- Allowed maneuvers at path end (stop line)
# -- All maneuvers with bits not set are therefore prohibited !
# -- A value of zero shall be used for unknown, indicating no Maneuver
# maneuverStraightAllowed(0),
# -- a Straight movement is allowed in this lane
# maneuverLeftAllowed(1),
# -- a Left Turn movement is allowed in this lane
# maneuverRightAllowed(2),
# -- a Right Turn movement is allowed in this lane
# maneuverUTurnAllowed(3),
# -- a U turn movement is allowed in this lane
# maneuverLeftTurnOnRedAllowed (4),
# -- a Stop, and then proceed when safe movement
# -- is allowed in this lane
# maneuverRightTurnOnRedAllowed (5),
# -- a Stop, and then proceed when safe movement
# -- is allowed in this lane
# maneuverLaneChangeAllowed(6),
# -- a movement which changes to an outer lane
# -- on the egress side is allowed in this lane
# -- (example: left into either outbound lane)
# maneuverNoStoppingAllowed(7),
# -- the vehicle should not stop at the stop line
# -- (example: a flashing green arrow)
# yieldAllwaysRequired(8),
# -- the allowed movements above are not protected
# -- (example: an permanent yellow condition)
# goWithHalt(9),
# -- after making a full stop, may proceed
# caution(10),
# -- proceed past stop line with caution
# reserved1(11)
# -- used to align to 12 Bit Field
# } (SIZE(12))

uint16 allowed_maneuvers

# Bit flags
uint16 STRAIGHT=1
uint16 LEFT_TURN=2
uint16 RIGHT_TURN=4
uint16 U_TURN=8
uint16 LEFT_TURN_ON_RED=16
uint16 RIGHT_TURN_ON_RED=32
uint16 LANE_CHANGE=64
uint16 NO_STOPPING_ALLOWED=128
uint16 ALWAYS_YIELD=256
uint16 GO_WITH_HALT=512
uint16 CAUTION=1024

================================================================================
MSG: j2735_msgs/NodeListXY
#
# NodeListXY.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The NodeListXY data structure provides the sequence of signed offset node point values for determining the Xs and
# Ys (and possibly Width or Zs when present), using the then current Position3D object to build a path for the centerline of
# the subject lane type. Each X,Y point is referred to as a Node Point. The straight line paths between these points are
# referred to as Segments.
#
# NodeListXY ::= CHOICE {
# nodes NodeSetXY,
# -- a lane made up of two or more
# -- XY node points and any attributes
# -- defined in those nodes
# computed ComputedLane,
# -- a lane path computed by translating
# -- the data defined by another lane
# ...
# }

uint8 choice
uint8 NODE_SET_XY=0
uint8 COMPUTED_LANE=1

j2735_msgs/NodeSetXY nodes
j2735_msgs/ComputedLane computed
================================================================================
MSG: j2735_msgs/NodeSetXY
#
# NodeListXY.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The NodeSetXY data frame consists of a list of Node entries using XY offsets.
#
# NodeSetXY ::= SEQUENCE (SIZE(2..63)) OF NodeXY

j2735_msgs/NodeXY[] node_set_xy
================================================================================
MSG: j2735_msgs/NodeXY
#
# NodeXY.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_NodeXY data frame presents a structure to hold data for a single node point in a path. Each selected node
# has an X and Y offset from the prior node point (or a complete lat-long representation in some cases) as well as optional
# attribute information.
#
# NodeXY ::= SEQUENCE {
# delta NodeOffsetPointXY,
# -- A choice of which X,Y offset value to use
# -- this includes various delta values as well a regional choices
# attributes NodeAttributeSetXY OPTIONAL,
# -- Any optional Attributes which are needed
# -- This includes changes to the current lane width and elevation
# ...
# }

j2735_msgs/NodeOffsetPointXY delta

j2735_msgs/NodeAttributeSetXY attributes
bool attributes_exists

================================================================================
MSG: j2735_msgs/NodeOffsetPointXY
#
# NodeOffsetPointXY.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_NodeOffsetPointXY data frame presents a structure to hold different sized data frames for a single node
# point in a lane. Nodes are described in terms of X and Y offsets in units of 1 centimeter (when zoom is 1:1).
#
# NodeOffsetPointXY ::= CHOICE {
# -- Nodes with X,Y content
# node-XY1 Node-XY-20b, -- node is within 5.11m of last node
# node-XY2 Node-XY-22b, -- node is within 10.23m of last node
# node-XY3 Node-XY-24b, -- node is within 20.47m of last node
# node-XY4 Node-XY-26b, -- node is within 40.96m of last node
# node-XY5 Node-XY-28b, -- node is within 81.91m of last node
# node-XY6 Node-XY-32b, -- node is within 327.67m of last node
# node-LatLon Node-LLmD-64b, -- node is a full 32b Lat/Lon range
# regional RegionalExtension {{REGION.Reg-NodeOffsetPointXY}}
# 	-- node which follows is of a
# 	-- regional definition type
# }
#

uint8 choice
uint8 NODE_XY1=0
uint8 NODE_XY2=1
uint8 NODE_XY3=2
uint8 NODE_XY4=3
uint8 NODE_XY5=4
uint8 NODE_XY6=5
uint8 NODE_LATLON=6

j2735_msgs/NodeXY20b node_xy1
j2735_msgs/NodeXY22b node_xy2
j2735_msgs/NodeXY24b node_xy3
j2735_msgs/NodeXY26b node_xy4
j2735_msgs/NodeXY28b node_xy5
j2735_msgs/NodeXY32b node_xy6
j2735_msgs/NodeLLmD64b node_latlon
# regional #TODO: RegionalExtensions are not yet implemented in asn1c
================================================================================
MSG: j2735_msgs/NodeXY20b
#
# NodeXY20b.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# A 20-bit node type with offset values from the last point in X and Y.
#
# Node-XY-20b ::= SEQUENCE {
# x Offset-B10,
# y Offset-B10
# }

# Offset-B10 ::= INTEGER (-512..511)
# -- a range of +- 5.11 meters
# A 10-bit delta offset in X, Y or Z direction from some known point. For non-vehicle centric coordinate frames of
# reference, offset is positive to the East (X) and to the North (Y) directions. The most negative value shall be used to
# indicate an unknown value.

float32 x
float32 y
================================================================================
MSG: j2735_msgs/NodeXY22b
#
# NodeXY22b.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# A 22-bit node type with offset values from the last point in X and Y.

# Node-XY-22b ::= SEQUENCE {
# x Offset-B11,
# y Offset-B11
# }

# Offset-B11 ::= INTEGER (-1024..1023)
# -- a range of +- 10.23 meters
# An 11-bit delta offset in X or Y direction from some known point. For non-vehicle centric coordinate frames of
# reference, offset is positive to the East (X) and to the North (Y) directions. The most negative value shall be used to
# indicate an unknown value.

float32 x
float32 y
================================================================================
MSG: j2735_msgs/NodeXY24b
#
# NodeXY24b.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# A 24-bit node type with offset values from the last point in X and Y.
#
# Node-XY-24b ::= SEQUENCE {
# x Offset-B12,
# y Offset-B12
# }


# Offset-B12 ::= INTEGER (-2048..2047)
# -- a range of +- 20.47 meters
# A 12-bit delta offset in X, Y or Z direction from some known point. For non-vehicle centric coordinate frames of
# reference, non-vehicle centric coordinate frames of reference, offset is positive to the East (X) and to the North (Y)
# directions. The most negative value shall be used to indicate an unknown value.

float32 x
float32 y
================================================================================
MSG: j2735_msgs/NodeXY26b
#
# NodeXY26b.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# A 26-bit node type with offset values from the last point in X and Y.

# Node-XY-26b ::= SEQUENCE {
# x Offset-B13,
# y Offset-B13
# }

# Offset-B13 ::= INTEGER (-4096..4095)
# -- a range of +- 40.95 meters
# A 13-bit delta offset in X or Y direction from some known point. For non-vehicle centric coordinate frames of
# reference, offset is positive to the East (X) and to the North (Y) directions. The most negative value shall be used to
# indicate an unknown value.

float32 x
float32 y
================================================================================
MSG: j2735_msgs/NodeXY28b
#
# NodeXY28b.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# A 28-bit node type with offset values from the last point in X and Y.

# Node-XY-28b ::= SEQUENCE {
# x Offset-B14,
# y Offset-B14
# }

# A 14-bit delta offset in X or Y direction from some known point. For non-vehicle centric coordinate frames of
# reference, offset is positive to the East (X) and to the North (Y) directions.
# Offset-B14 ::= INTEGER (-8192..8191)
# -- a range of +- 81.91 meters

float32 x
float32 y

================================================================================
MSG: j2735_msgs/NodeXY32b
#
# NodeXY32b.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# A 32-bit node type with offset values from the last point in X and Y.

# Node-XY-32b ::= SEQUENCE {
# x Offset-B16,
# y Offset-B16
# }

# A 16-bit delta offset in X, Y or Z direction from some known point. For non-vehicle centric coordinate frames of
# reference, offset is positive to the East (X) and to the North (Y) directions. The most negative value shall be used to
# indicate an unknown value.
# Offset-B16 ::= INTEGER (-32768..32767)
# -- a range of +- 327.68 meters

float32 x
float32 y
================================================================================
MSG: j2735_msgs/NodeLLmD64b
#
# NodeLLmD64b.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# A 64-bit node type with lat-long values expressed in standard SAE one tenth of a micro degree.

# Node-LLmD-64b ::= SEQUENCE {
# lon Longitude,
# lat Latitude
# }

#Longitude ::= INTEGER (-1799999999..1800000001)
#  -- LSB = 1/10 micro degree
#  -- Providing a range of plus-minus 180 degrees
#  -- Convert to degree with factor 0.0000001 when field is used
int32 longitude

int32 LONGITUDE_UNAVAILABLE = 1800000001
int32 LONGITUDE_MAX = 1800000000
int32 LONGITUDE_MIN = -1799999999

#Latitude ::= INTEGER (-900000000..900000001)
#  -- LSB = 1/10 micro degree
#  -- Providing a range of plus-minus 90 degrees
#  -- Convert to degree with factor 0.0000001 when field is used
int32 latitude

int32 LATITUDE_UNAVAILABLE = 900000001
int32 LATITUDE_MAX = 900000000
int32 LATITUDE_MIN = -900000000





================================================================================
MSG: j2735_msgs/NodeAttributeSetXY
#
# NodeAttributeSetXY.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_NodeAttributeSetXY is a data frame used to convey one or more changes in the attribute set which occur
# at the node point at which it is used. Some of these attributes persist until the end of the lane or until changed again or
# turned off.
#
# NodeAttributeSetXY ::= SEQUENCE {
# localNode NodeAttributeXYList OPTIONAL,
# -- Attribute states which pertain to this node point
# disabled SegmentAttributeXYList OPTIONAL,
# -- Attribute states which are disabled at this node point
# enabled SegmentAttributeXYList OPTIONAL,
# -- Attribute states which are enabled at this node point
# -- and which remain enabled until disabled or the lane ends
# data LaneDataAttributeList OPTIONAL,
# -- Attributes which require an additional data values
# -- some of these are local to the node point, while others
# -- persist with the provided values until changed
# -- and this is indicated in each entry
# dWidth Offset-B10 OPTIONAL,
# -- A value added to the current lane width
# -- at this node and from this node onwards, in 1cm steps
# -- lane width between nodes are a linear taper between pts
# -- the value of zero shall not be sent here
# dElevation Offset-B10 OPTIONAL,
# -- A value added to the current Elevation
# -- at this node from this node onwards, in 10cm steps
# -- elevations between nodes are a linear taper between pts
# -- the value of zero shall not be sent here
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-NodeAttributeSetXY}}OPTIONAL,
# ...
# }

j2735_msgs/NodeAttributeXYList local_node
bool local_node_exists

j2735_msgs/SegmentAttributeXYList disabled
bool disabled_exists

j2735_msgs/SegmentAttributeXYList enabled
bool enabled_exists

j2735_msgs/LaneDataAttributeList data
bool data_exists

# Offset-B10 ::= INTEGER (-512..511)
# -- a range of +- 5.11 meters
float32 dWitdh
bool dWitdh_exists

float32 dElevation
bool dElevation_exists

# regional #TODO: RegionalExtensions are not yet implemented in asn1c
================================================================================
MSG: j2735_msgs/NodeAttributeXYList
#
# NodeAttributeXYList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The NodeAttributeXYList data frame consists of a list of NodeAttributeXY entries.
#
# NodeAttributeXYList ::= SEQUENCE (SIZE(1..8)) OF NodeAttributeXY

j2735_msgs/NodeAttributeXY[] node_attribute_xy_List

================================================================================
MSG: j2735_msgs/NodeAttributeXY
#
# NodeAttributeXY.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DE_NodeAttributeXY data element is an enumerated list of attributes which can pertain to the current node
# point.
#
# NodeAttributeXY ::= ENUMERATED {
# -- Various values which pertain only to the current node point
#
# -- General Items
# reserved,
# stopLine,		-- point where a mid-path stop line exists
# 			-- See also 'do not block' for segments
# -- Path finish details
# roundedCapStyleA, 	-- Used to control final path rounded end shape
# 		   	-- with edge of curve at final point in a circle
# roundedCapStyleB,	-- Used to control final path rounded end shape
# 			-- with edge of curve extending 50% of width past
# 			-- final point in a circle
#
# -- Topography Points (items with no concept of a distance along the path)
# mergePoint,		-- Japan merge with 1 or more lanes
# divergePoint,		-- Japan diverge with 1 or more lanes
# downstreamStopLine,	-- Japan style downstream intersection
# 			-- (a 2nd intersection) stop line
# downstreamStartNode, 	-- Japan style downstream intersection
# 			-- (a 2nd intersection) start node
#
# -- Pedestrian Support Attributes
# closedToTraffic,	-- where a pedestrian may NOT go
# 			-- to be used during construction events
# safeIsland,		-- a pedestrian safe stopping point
# 			-- also called a traffic island
# 			-- This usage described a point feature on a path,
# 			-- other entries can describe a path
# curbPresentAtStepOff, 	-- the sidewalk to street curb is NOT
# 			-- angled where it meets the edge of the
# 			-- roadway (user must step up/down)
# -- Lane geometry details (see standard for defined shapes)
# hydrantPresent,		-- Or other services access
# ...
# }


uint8  node_attribute_xy

# enumeration values for status:
uint8 RESERVED=0
uint8 STOPLINE=1
uint8 ROUNDEDCAPSTYLEA=2
uint8 ROUNDEDCAPSTYLEB=3
uint8 MERGEPOINT=4
uint8 DIVERGEPOINT=5
uint8 DOWNSTREAMSTOPLINE=6
uint8 DOWNSTREAMSTARTNODE=7
uint8 CLOSEDTOTRAFFIC=8
uint8 SAFEISLAND=9
uint8 CURBPRESENTATSTEPOFF=10
uint8 HYDRANTPRESENT=11

================================================================================
MSG: j2735_msgs/SegmentAttributeXYList
#
# NodeAttributeXYList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
#The DF_SegmentAttributeXYList data frame consists of a list of SegmentAttributeXY entries.

#SegmentAttributeXYList ::= SEQUENCE (SIZE(1..8)) OF SegmentAttributeXY

j2735_msgs/SegmentAttributeXY[] segment_attribute_xy


================================================================================
MSG: j2735_msgs/SegmentAttributeXY
#
# SegmentAttributeXY.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DE_SegmentAttributeXY data element is an enumerated list of attributes about the current lane segment which
# may be enabled or disabled to indicate the presence or absence of the selected attribute on the segment.
#
# SegmentAttributeXY ::= ENUMERATED {
# -- Various values which can be Enabled and Disabled for a lane segment
#
# -- General Items
# reserved	,
# doNotBlock	, 	-- segment where a vehicle
# 		  	-- may not come to a stop
# whiteLine	, 	-- segment where lane crossing not allowed
# 		  	-- such as the final few meters of a lane
#
# -- Porous Lane states, merging, turn outs, parking etc.
# mergingLaneLeft,  	-- indicates porous lanes
# mergingLaneRight,
# curbOnLeft,	  	-- indicates presence of curbs
# curbOnRight,
# loadingzoneOnLeft,	-- loading or drop off zones
# loadingzoneOnRight,
# turnOutPointOnLeft,	-- opening to adjacent street/alley/road
# turnOutPointOnRight,
# adjacentParkingOnLeft, 	-- side of road parking
# adjacentParkingOnRight,
#
# -- Bike Lane Needs
# adjacentBikeLaneOnLeft, -- presence of marked bike lanes
# adjacentBikeLaneOnRight,
# sharedBikeLane, 	-- right of way is shared with bikes
# 			-- who may occupy entire lane width
# bikeBoxInFront,
#
# -- Transit Needs
# transitStopOnLeft,	-- any form of bus/transit loading
# 			-- with pull in-out access to lane on left
# transitStopOnRight, 	-- any form of bus/transit loading
# 			-- with pull in-out access to lane on right
# transitStopInLane, 	-- any form of bus/transit loading
# 			-- in mid path of the lane
# sharedWithTrackedVehicle, -- lane is shared with train or trolley
# 			-- not used for crossing tracks
#
# -- Pedestrian Support Attributes
# safeIsland, 		-- begin/end a safety island in path
# lowCurbsPresent, 	-- for ADA support
# rumbleStripPresent, 	-- for ADA support
# audibleSignalingPresent, -- for ADA support
# adaptiveTimingPresent, 	-- for ADA support
# rfSignalRequestPresent, -- Supports RF push to walk technologies
# partialCurbIntrusion, 	-- path is blocked by a median or curb
# 			-- but at least 1 meter remains open for use
# 			-- and at-grade passage
#
# -- Lane geometry details
# taperToLeft,		-- Used to control final path shape
# taperToRight,		-- Used to control final path shape
# taperToCenterLine,	-- Used to control final path shape
#
# -- Parking Lane and Curb Attributes
# parallelParking, 	-- Parking at an angle with the street
# freeParking, 		-- no restriction on use of parking
# timeRestrictionsOnParking , -- Parking is not permitted at all times
# 			-- typically used when the 'parking' lane
# 			-- becomes a driving lane at times
# costToPark, 		-- Used where parking has a cost
# midBlockCurbPresent, 	-- a protruding curb near lane edge
# unEvenPavementPresent, 	-- a disjoint height at lane edge
# ...
# }

uint8  segment_attribute_xy

uint8 RESERVED=0
uint8 DONOTBLOCK=1
uint8 WHITELINE=2
uint8 MERGINGLANELEFT=3
uint8 MERGINGLANERIGHT=4
uint8 CURBONLEFT=5
uint8 CURBONRIGHT=6
uint8 LOADINGZONEONLEFT=7
uint8 LOADINGZONEONRIGHT=8
uint8 TURNOUTPOINTONLEFT=9
uint8 TURNOUTPOINTONRIGHT=10
uint8 ADJACENTPARKINGONLEFT=11
uint8 ADJACENTPARKINGONRIGHT=12
uint8 ADJACENTBIKELANEONLEFT=13
uint8 ADJACENTBIKELANEONRIGHT=14
uint8 SHAREDBIKELANE=15
uint8 BIKEBOXINFRONT=16
uint8 TRANSITSTOPONLEFT=17
uint8 TRANSITSTOPONRIGHT=18
uint8 TRANSITSTOPINLANE=19
uint8 SHAREDWITHTRACKEDVEHICLE=20
uint8 SAFEISLAND=21
uint8 LOWCURBSPRESENT=22
uint8 RUMBLESTRIPPRESENT=23
uint8 AUDIBLESIGNALINGPRESENT=24
uint8 ADAPTIVETIMINGPRESENT=25
uint8 RFSIGNALREQUESTPRESENT=26
uint8 PARTIALCURBINTRUSION=27
uint8 TAPERTOLEFT=28
uint8 TAPERTORIGHT=29
uint8 TAPERTOCENTERLINE=30
uint8 PARALLELPARKING=31
uint8 FREEPARKING=32
uint8 TIMERESTRICTIONSONPARKING=33
uint8 COSTTOPARK=34
uint8 MIDBLOCKCURBPRESENT=35
uint8 UNEVENPAVEMENTPRESENT=36


================================================================================
MSG: j2735_msgs/LaneDataAttributeList
#
# LaneDataAttributeList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The LaneDataAttributeList data frame consists of a list of LaneDataAttribute entries.
#
# LaneDataAttributeList ::= SEQUENCE (SIZE(1..8)) OF LaneDataAttribute

j2735_msgs/LaneDataAttribute[] lane_attribute_list
================================================================================
MSG: j2735_msgs/LaneDataAttribute


# The data frame DF_LaneDataAttribute is used to relate an attribute and a control value at a node point or along a
# lane segment from an enumerated list of defined choices. It is then followed by a defined data value associated with it and
# which is defined elsewhere in this standard.


# LaneDataAttribute ::= CHOICE {
# -- Segment attribute types and the data needed for each
# pathEndPointAngle DeltaAngle,
# -- adjusts final point/width slant
# -- of the lane to align with the stop line
# laneCrownPointCenter RoadwayCrownAngle,
# -- sets the canter of the road bed
# -- from centerline point
# laneCrownPointLeft RoadwayCrownAngle,
# -- sets the canter of the road bed
# -- from left edge
# laneCrownPointRight RoadwayCrownAngle,
# -- sets the canter of the road bed
# -- from right edge
# laneAngle MergeDivergeNodeAngle,
# -- the angle or direction of another lane
# -- this is required to support Japan style
# -- when a merge point angle is required
# speedLimits SpeedLimitList,
# -- Reference regulatory speed limits
# -- used by all segments
# -- Add others as needed, in regional space
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-LaneDataAttribute}},
# ...
# }

uint8 choice
uint8 PATH_END_POINT_ANGLE=0
uint8 LANE_CROWN_POINT_CENTER=1
uint8 LANE_CROWN_POINT_LEFT=2
uint8 LANE_CROWN_POINT_RIGHT=3
uint8 LANE_ANGLE=4
uint8 SPEED_LIMITS=5

# DeltaAngle ::= INTEGER (-150..150)
# -- With an angle range from
# -- negative 150 to positive 150
# -- in one degree steps where zero is directly
# -- along the axis or the lane center line as defined by the
# -- two closest points
#
# The DeltaAngle data element provides the final angle used in the last point of the lane path.
# Used to "cant" the stop line of the lane.

int16 path_end_point_angle

# RoadwayCrownAngle ::= INTEGER (-128..127)
# -- In LSB units of 0.3 degrees of angle
# -- over a range of -38.1 to + 38.1 degrees
# -- The value -128 shall be used for unknown
# -- The value zero shall be used for angles
# -- which are between -0.15 and +0.15
#
# The RoadwayCrownAngle data element relates the gross tangential angle of the roadway surface with respect to
# the local horizontal axis and is measured at the indicated part of the lane.

int8 lane_crown_point_center
int8 lane_crown_point_right
int8 lane_crown_point_left

# MergeDivergeNodeAngle ::= INTEGER (-180..180)
# -- In units of 1.5 degrees from north
# -- the value -180 shall be used to represent
# -- data is not available or unknown
int16 lane_angle

# SpeedLimitList ::= SEQUENCE (SIZE(1..9)) OF RegulatorySpeedLimit
j2735_msgs/SpeedLimitList speed_limits

# regional #TODO: RegionalExtensions are not yet implemented in asn1c

================================================================================
MSG: j2735_msgs/ComputedLane
#
# NodeListXY.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# ComputedLane ::= SEQUENCE {
# -- Data needed to created a computed lane
# referenceLaneId LaneID,
# 	-- the lane ID upon which this
# 	-- computed lane will be based
# 	-- Lane Offset in X and Y direction
# offsetXaxis CHOICE {
# 		small DrivenLineOffsetSm,
# 		large DrivenLineOffsetLg
# 		},
# offsetYaxis CHOICE {
# 		small DrivenLineOffsetSm,
# 		large DrivenLineOffsetLg
# 		},
# 	-- A path X offset value for translations of the
# 	-- path's points when creating translated lanes.
# 	-- The values found in the reference lane are
# 	-- all offset based on the X and Y values from
# 	-- the coordinates of the reference lane's
# 	-- initial path point.
#
# -- Lane Rotation
# rotateXY Angle OPTIONAL,
# 	-- A path rotation value for the entire lane
# 	-- Observe that this rotates the existing orientation
# 	-- of the referenced lane, it does not replace it.
# 	-- Rotation occurs about the initial path point.
# -- Lane Path Scale (zooming)
# scaleXaxis Scale-B12 OPTIONAL,
# scaleYaxis Scale-B12 OPTIONAL,
# 	-- value for translations or zooming of the path's
# 	-- points. The values found in the reference lane
# 	-- are all expanded or contracted based on the X
# 	-- and Y and width values from the coordinates of
# 	-- the reference lane's initial path point.
# 	-- The Z axis remains untouched.
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-ComputedLane}} OPTIONAL,
# ...
# }

# LaneID ::= INTEGER (0..255)
# -- the value 0 shall be used when the lane ID is
# -- not available or not known
# -- the value 255 is reserved for future use
uint16 reference_lane_id

# The DrivenLineOffsetSmall data element is an integer value expressing the offset in a defined axis from a reference
# lane number from which a computed lane is offset.
# DrivenLineOffsetSm ::= INTEGER (-2047..2047)
# -- LSB units are 1 cm.
# The DE_DrivenLineOffsetLarge data element is an integer value expressing the offset in a defined axis from a
# reference lane number from which a computed lane is offset.
# DrivenLineOffsetLg ::= INTEGER (-32767..32767)
# -- LSB units are 1 cm.

j2735_msgs/OffsetXaxis offset_x_axis

j2735_msgs/OffsetYaxis offset_y_axis

# Angle ::= INTEGER (0..239)
#  -- Unsigned units of 1.5 degree, in 1 octet
#  -- the true north is 0, positive is clockwise
#  -- the values 240 to 254 shall not be sent
#  -- the value 255 (0xFF) indicates an invalid value
# NOTE: use invalid value to indicate unavailability as well.
uint16 rotateXY
uint16 ROTATEXY_INVALID=255
bool rotatexy_exists

# Scale-B12 ::= INTEGER (-2048..2047)
# A 12-bit signed scaling factor supporting scales from zero (which is not used) to >200%.
# In this data element, the value zero is taken to represent a value of one (scale 1:1).
int16 scale_x_axis
bool scale_x_axis_exists

int16 scale_y_axis
bool scale_y_axis_exists

# regional #TODO: RegionalExtensions are not yet implemented in asn1c

================================================================================
MSG: j2735_msgs/OffsetXaxis
#
# OffsetXaxis.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# 	-- A path X offset value for translations of the
# 	-- path's points when creating translated lanes.
# 	-- The values found in the reference lane are
# 	-- all offset based on the X and Y values from
# 	-- the coordinates of the reference lane's
# 	-- initial path point.
# offsetXaxis CHOICE {
# 		small DrivenLineOffsetSm,
# 		large DrivenLineOffsetLg
# 		},


uint8 choice
uint8 SMALL=0
uint8 LARGE=1

# The DrivenLineOffsetSmall data element is an integer value expressing the offset in a defined axis from a reference
# lane number from which a computed lane is offset.
# DrivenLineOffsetSm ::= INTEGER (-2047..2047)
# -- LSB units are 1 cm.
int16 small


# The DE_DrivenLineOffsetLarge data element is an integer value expressing the offset in a defined axis from a
# reference lane number from which a computed lane is offset.
# DrivenLineOffsetLg ::= INTEGER (-32767..32767)
# -- LSB units are 1 cm.
int16 large
================================================================================
MSG: j2735_msgs/OffsetYaxis
#
# OffsetYaxis.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# 	-- A path X offset value for translations of the
# 	-- path's points when creating translated lanes.
# 	-- The values found in the reference lane are
# 	-- all offset based on the X and Y values from
# 	-- the coordinates of the reference lane's
# 	-- initial path point.
# offsetYaxis CHOICE {
# 		small DrivenLineOffsetSm,
# 		large DrivenLineOffsetLg
# 		},

uint8 choice
uint8 SMALL=0
uint8 LARGE=1

# The DrivenLineOffsetSmall data element is an integer value expressing the offset in a defined axis from a reference
# lane number from which a computed lane is offset.
# DrivenLineOffsetSm ::= INTEGER (-2047..2047)
# -- LSB units are 1 cm.
int16 small


# The DE_DrivenLineOffsetLarge data element is an integer value expressing the offset in a defined axis from a
# reference lane number from which a computed lane is offset.
# DrivenLineOffsetLg ::= INTEGER (-32767..32767)
# -- LSB units are 1 cm.
int16 large
================================================================================
MSG: j2735_msgs/ConnectsToList
#
# ConnectsToList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The ConnectsToList data structure is used in the generic lane descriptions to provide a sequence of other defined
# lanes to which each lane connects beyond its stop point. See the Connection data frame entry for details. Note that this
# data frame is not used in some lane object types.
#
# ConnectsToList ::= SEQUENCE (SIZE(1..16)) OF Connection

j2735_msgs/Connection[] connect_to_list

================================================================================
MSG: j2735_msgs/Connection
#
# Connection.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The Connection data structure is used in the ConnectsToList data frame to provide data about how the stop line at
# the end of a single lane connects to another lane beyond its stop point. The ConnectingLane entry ties an outbound
# (egress) lane by its index to a valid single maneuver required to reach that outbound lane. The SignalGroupID maps this
# to a single SPAT index. (Note that more than one entry can exist for any given lane to handle admissive and protected
# conditions).
#
# Connection ::= SEQUENCE {
# -- The subject lane connecting to this lane is:
# connectingLane ConnectingLane,
# -- The index of the connecting lane and also
# -- the maneuver from the current lane to it
# remoteIntersection IntersectionReferenceID OPTIONAL,
# -- This entry is only used when the
# -- indicated connecting lane belongs
# -- to another intersection layout. This
# -- provides a means to create meshes of lanes
# -- SPAT mapping details at the stop line are:
# signalGroup SignalGroupID OPTIONAL,
# -- The matching signal group send by
# -- the SPAT message for this lane/maneuver.
# -- Shall be present unless the connectingLane
# -- has no signal group (is un-signalized)
# userClass RestrictionClassID OPTIONAL,
# -- The Restriction Class of users this applies to
# -- The use of some lane/maneuver and SignalGroupID
# -- pairings are restricted to selected users.
# -- When absent, the SignalGroupID applies to all
# -- Movement assist details are given by:
# connectionID LaneConnectionID OPTIONAL
# -- An optional connection index used to
# -- relate this lane connection to any dynamic
# -- clearance data in the SPAT. Note that
# -- the index may be shared with other
# -- connections if the clearance data is common
# }

j2735_msgs/ConnectingLane connecting_lane

j2735_msgs/IntersectionReferenceID remote_intersection
bool remote_intersection_exists

# SignalGroupID ::= INTEGER (0..255)
uint8 signal_group
bool signal_group_exists

# RestrictionClassID ::= INTEGER (0..255)
uint8 user_class
bool user_class_exists

# LaneConnectionID ::= INTEGER (0..255)
uint8 connection_id
bool connection_id_exists

================================================================================
MSG: j2735_msgs/ConnectingLane
#
# ConnectingLane.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# ConnectingLane ::= SEQUENCE {
# lane LaneID,
# -- Index of the connecting lane
# maneuver AllowedManeuvers OPTIONAL
# -- The Maneuver between
# -- the enclosing lane and this lane
# -- at the stop line to connect them
# }

# LaneID ::= INTEGER (0..255)
# -- the value 0 shall be used when the lane ID is
# -- not available or not known
# -- the value 255 is reserved for future use
uint16 lane
uint16 LANE_UNAVAILABLE=0

# -- the permitted maneuvers for this lane
# AllowedManeuvers ::= BIT STRING {
# -- With bits as defined:
# -- Allowed maneuvers at path end (stop line)
# -- *** All maneuvers with bits not set are therefore prohibited ! ***
# -- A value of zero shall be used for unknown, indicating no Maneuver
j2735_msgs/AllowedManeuvers maneuver
bool maneuver_exists



================================================================================
MSG: j2735_msgs/OverlayLaneList
#
# OverlayLaneList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The Overlay Lane List data frame is a sequence of lane IDs which refers to lane objects that overlap or overlay the
# current lane's spatial path.
#  OverlayLaneList ::= SEQUENCE (SIZE(1..5)) OF LaneID
# -- The unique ID numbers for any lane object which have
# -- spatial paths that overlay (run on top of, and not
# -- simply cross with) the current lane.
# -- Such as a train path that overlays a motor vehicle
# -- lane object for a roadway segment.

# LaneID ::= INTEGER (0..255)
# -- the value 0 shall be used when the lane ID is
# -- not available or not known
# -- the value 255 is reserved for future use
uint16[] overlay_lane_list
================================================================================
MSG: j2735_msgs/PreemptPriorityList
#
# PreemptPriorityList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_PreemptPriorityList data frame consists of a list of RegionalSignalControlZone entries.
#
# PreemptPriorityList ::= SEQUENCE (SIZE(1..32)) OF SignalControlZone
#
#

j2735_msgs/SignalControlZone[] preempt_priority_list


================================================================================
MSG: j2735_msgs/SignalControlZone
#
# SignalControlZone.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# SignalControlZone ::= SEQUENCE {
# zone RegionalExtension {{REGION.Reg-SignalControlZone}},
# ...
# }
#
# regional_extension  #TODO: RegionalExtensions are not yet implemented in asn1c
================================================================================
MSG: j2735_msgs/RoadSegmentList
#
# MapData.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# Used By: This entry is used directly by one other data structure in this standard, a MSG called MSG_MapData (MAP)
# <ASN>. In addition, this item may be used by data structures in other ITS standards.

# RoadSegmentList ::= SEQUENCE (SIZE(1..32)) OF RoadSegment

j2735_msgs/RoadSegment[] road_segment_list
================================================================================
MSG: j2735_msgs/RoadSegment
#
# RoadSegment.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_ RoadSegment data frame is a complete description of a RoadSegment including its geometry and its
# allowed navigational paths (independent of any additional regulatory restrictions that may apply over time or from user
# classification) and any current disruptions such as a work zone or incident event.
#
# RoadSegment ::= SEQUENCE {
# name DescriptiveName OPTIONAL,
# id RoadSegmentReferenceID,
# -- a globally unique value for the segment
# revision MsgCount,
# -- Required default values about the descriptions to follow
# refPoint Position3D,
# -- the reference from which subsequent
# -- data points are offset until a new
# -- point is used.
# laneWidth LaneWidth OPTIONAL,
# -- Reference width used by all subsequent
# -- lanes unless a new width is given
# speedLimits SpeedLimitList OPTIONAL,
# -- Reference regulatory speed limits
# -- used by all subsequent
# -- lanes unless a new speed is given
# -- See Section 11 for converting and
# -- translating speed expressed in mph
# -- into units of m/s
# -- Data describing disruptions in the RoadSegment
# -- such as work zones etc will be added here;
# -- in the US the SAE ITIS codes would be used here
# -- The details regarding each lane type in the RoadSegment
# roadLaneSet RoadLaneSetList,
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-RoadSegment}} OPTIONAL,
# ...
# }

# name DescriptiveName OPTIONAL := IA5String (SIZE(1..63))
# -- often for debug use only
# -- but at times used to name ped crossings
string name
bool name_exists

j2735_msgs/RoadSegmentReferenceID id

#MsgCount ::= INTEGER (0..127)
uint8 revision

j2735_msgs/Position3D ref_point

# LaneWidth OPTIONAL ::= INTEGER (0..32767) -- units of 1 cm
uint16 lane_width
bool lane_width_exists

j2735_msgs/SpeedLimitList speed_limits
bool speed_limits_exists

j2735_msgs/RoadLaneSetList road_lane_set

#regional #TODO: RegionalExtensions are not yet implemented in asn1c





================================================================================
MSG: j2735_msgs/RoadSegmentReferenceID
#
# RoadSegmentReferenceID.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_RoadSegmentReferenceID data frame is used to convey theRoadSegmentID which is unique to a given
# road segment of interest, and also the RoadRegulatorID assigned to the region in which it is operating (when required).

# RoadSegmentReferenceID ::= SEQUENCE {
# region RoadRegulatorID OPTIONAL,
# -- a globally unique regional assignment value
# -- typically assigned to a regional DOT authority
# -- the value zero shall be used for testing needs
# id RoadSegmentID
# -- a unique mapping to the road segment
# -- in question within the above region of use
# -- during its period of assignment and use
# -- note that unlike intersectionID values,
# -- this value can be reused by the region
# }

# RoadRegulatorID ::= INTEGER (0..65535)
uint16 region
bool region_exists

# RoadSegmentID ::= INTEGER (0..65535)
# -- The values zero to 255 shall be used for testing only
# -- Note that the value assigned to an RoadSegment will be
# -- unique within a given regional ID only during its use
uint16 id
bool id_exists




================================================================================
MSG: j2735_msgs/RoadLaneSetList
#
# RoadLaneSetList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_RoadLaneSetList data frame consists of a list of GenericLane entries used to describe a segment of
#  roadway.
#
# RoadLaneSetList ::= SEQUENCE (SIZE(1..255)) OF GenericLane

j2735_msgs/GenericLane[] road_lane_set_list
================================================================================
MSG: j2735_msgs/DataParameters
#
# MapData.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DataParameters data frame is used to provide basic (static) information
# on how a map fragment was processed or determined.
#
# DataParameters ::= SEQUENCE {
# processMethod IA5String(SIZE(1..255))
# processAgency IA5String(SIZE(1..255))
# lastCheckedDate IA5String(SIZE(1..255))
# geoidUsed IA5String(SIZE(1..255))
# ...
# }
#

string process_method
string process_agency
string last_checked_date
string geoid_used
================================================================================
MSG: j2735_msgs/RestrictionClassList
#
# RestrictionClassList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_RestrictionClassList data frame is used to enumerate a list of user classes which belong to a given
# assigned index. The resulting collection is treated as a group by the signal controller when it issues movement data
# (signal phase information) with the GroupID for this group. This data frame is typically static for long periods of time
# (months) and conveyed to the user by means of the MAP message.

# RestrictionClassList ::= SEQUENCE (SIZE(1..254)) OF RestrictionClassAssignment

j2735_msgs/RestrictionClassAssignment[] restriction_class_list
================================================================================
MSG: j2735_msgs/RestrictionClassAssignment
#
# RestrictionClassAssignment.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_RestrictionClassAssignment data frame is used to assign (or bind) a single RestrictionClassID data
# element to a list of all user classes to which it applies. A collection of these bindings is conveyed in the
# RestrictionClassList data frame in the MAP message to travelers.
#
# RestrictionClassAssignment ::= SEQUENCE {
# id RestrictionClassID,
# -- the unique value (within an intersection or local region)
# -- that is assigned to this group of users
# users RestrictionUserTypeList
# -- The list of user types/classes
# -- to which this restriction ID applies
# }

# RestrictionClassID ::= INTEGER (0..255)
uint8 id


"""
  __slots__ = ['header','time_stamp','time_stamp_exists','msg_issue_revision','layer_type','layer_id','layer_id_exists','intersections','intersections_exists','road_segments','road_segments_exists','data_parameters','data_parameters_exists','restriction_list','restriction_list_exists']
  _slot_types = ['std_msgs/Header','uint32','bool','uint8','j2735_msgs/LayerType','uint8','bool','j2735_msgs/IntersectionGeometry[]','bool','j2735_msgs/RoadSegmentList','bool','j2735_msgs/DataParameters','bool','j2735_msgs/RestrictionClassList','bool']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,time_stamp,time_stamp_exists,msg_issue_revision,layer_type,layer_id,layer_id_exists,intersections,intersections_exists,road_segments,road_segments_exists,data_parameters,data_parameters_exists,restriction_list,restriction_list_exists

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(MapData, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.time_stamp is None:
        self.time_stamp = 0
      if self.time_stamp_exists is None:
        self.time_stamp_exists = False
      if self.msg_issue_revision is None:
        self.msg_issue_revision = 0
      if self.layer_type is None:
        self.layer_type = j2735_msgs.msg.LayerType()
      if self.layer_id is None:
        self.layer_id = 0
      if self.layer_id_exists is None:
        self.layer_id_exists = False
      if self.intersections is None:
        self.intersections = []
      if self.intersections_exists is None:
        self.intersections_exists = False
      if self.road_segments is None:
        self.road_segments = j2735_msgs.msg.RoadSegmentList()
      if self.road_segments_exists is None:
        self.road_segments_exists = False
      if self.data_parameters is None:
        self.data_parameters = j2735_msgs.msg.DataParameters()
      if self.data_parameters_exists is None:
        self.data_parameters_exists = False
      if self.restriction_list is None:
        self.restriction_list = j2735_msgs.msg.RestrictionClassList()
      if self.restriction_list_exists is None:
        self.restriction_list_exists = False
    else:
      self.header = std_msgs.msg.Header()
      self.time_stamp = 0
      self.time_stamp_exists = False
      self.msg_issue_revision = 0
      self.layer_type = j2735_msgs.msg.LayerType()
      self.layer_id = 0
      self.layer_id_exists = False
      self.intersections = []
      self.intersections_exists = False
      self.road_segments = j2735_msgs.msg.RoadSegmentList()
      self.road_segments_exists = False
      self.data_parameters = j2735_msgs.msg.DataParameters()
      self.data_parameters_exists = False
      self.restriction_list = j2735_msgs.msg.RestrictionClassList()
      self.restriction_list_exists = False

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_I5B().pack(_x.time_stamp, _x.time_stamp_exists, _x.msg_issue_revision, _x.layer_type.layer_type, _x.layer_id, _x.layer_id_exists))
      length = len(self.intersections)
      buff.write(_struct_I.pack(length))
      for val1 in self.intersections:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.name_exists
        buff.write(_get_struct_B().pack(_x))
        _v1 = val1.id
        _x = _v1
        buff.write(_get_struct_HBH().pack(_x.region, _x.region_exists, _x.id))
        _x = val1.revision
        buff.write(_get_struct_B().pack(_x))
        _v2 = val1.ref_point
        _x = _v2
        buff.write(_get_struct_2dfB().pack(_x.latitude, _x.longitude, _x.elevation, _x.elevation_exists))
        _x = val1
        buff.write(_get_struct_HB().pack(_x.lane_width, _x.lane_width_exists))
        _v3 = val1.speed_limits
        length = len(_v3.speed_limits)
        buff.write(_struct_I.pack(length))
        for val3 in _v3.speed_limits:
          _v4 = val3.type
          _x = _v4.speed_limit_type
          buff.write(_get_struct_B().pack(_x))
          _x = val3.speed
          buff.write(_get_struct_d().pack(_x))
        _x = val1.speed_limits_exists
        buff.write(_get_struct_B().pack(_x))
        _v5 = val1.lane_set
        length = len(_v5.lane_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v5.lane_list:
          _x = val3.lane_id
          buff.write(_get_struct_B().pack(_x))
          _x = val3.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_5B().pack(_x.name_exists, _x.ingress_approach, _x.ingress_approach_exists, _x.egress_approach, _x.egress_approach_exists))
          _v6 = val3.lane_attributes
          _v7 = _v6.directional_use
          _x = _v7.lane_direction
          buff.write(_get_struct_B().pack(_x))
          _v8 = _v6.shared_with
          _x = _v8.lane_sharing
          buff.write(_get_struct_H().pack(_x))
          _v9 = _v6.laneType
          _x = _v9.choice
          buff.write(_get_struct_B().pack(_x))
          _v10 = _v9.vehicle
          _x = _v10.lane_attributes_vehicle
          buff.write(_get_struct_B().pack(_x))
          _v11 = _v9.crosswalk
          _x = _v11.lane_attributes_crosswalk
          buff.write(_get_struct_H().pack(_x))
          _v12 = _v9.bikeLane
          _x = _v12.lane_attributes_bike
          buff.write(_get_struct_H().pack(_x))
          _v13 = _v9.sidewalk
          _x = _v13.lane_attributes_sidewalk
          buff.write(_get_struct_H().pack(_x))
          _v14 = _v9.median
          _x = _v14.lane_attributes_barrier
          buff.write(_get_struct_H().pack(_x))
          _v15 = _v9.striping
          _x = _v15.lane_attributes_striping
          buff.write(_get_struct_H().pack(_x))
          _v16 = _v9.trackedVehicle
          _x = _v16.lane_attributes_trackedvehicle
          buff.write(_get_struct_H().pack(_x))
          _v17 = _v9.parking
          _x = _v17.lane_attributes_parking
          buff.write(_get_struct_H().pack(_x))
          _v18 = val3.maneuvers
          _x = _v18.allowed_maneuvers
          buff.write(_get_struct_H().pack(_x))
          _x = val3.maneuvers_exists
          buff.write(_get_struct_B().pack(_x))
          _v19 = val3.node_list
          _x = _v19.choice
          buff.write(_get_struct_B().pack(_x))
          _v20 = _v19.nodes
          length = len(_v20.node_set_xy)
          buff.write(_struct_I.pack(length))
          for val6 in _v20.node_set_xy:
            _v21 = val6.delta
            _x = _v21.choice
            buff.write(_get_struct_B().pack(_x))
            _v22 = _v21.node_xy1
            _x = _v22
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v23 = _v21.node_xy2
            _x = _v23
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v24 = _v21.node_xy3
            _x = _v24
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v25 = _v21.node_xy4
            _x = _v25
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v26 = _v21.node_xy5
            _x = _v26
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v27 = _v21.node_xy6
            _x = _v27
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v28 = _v21.node_latlon
            _x = _v28
            buff.write(_get_struct_2i().pack(_x.longitude, _x.latitude))
            _v29 = val6.attributes
            _v30 = _v29.local_node
            length = len(_v30.node_attribute_xy_List)
            buff.write(_struct_I.pack(length))
            for val9 in _v30.node_attribute_xy_List:
              _x = val9.node_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v29.local_node_exists
            buff.write(_get_struct_B().pack(_x))
            _v31 = _v29.disabled
            length = len(_v31.segment_attribute_xy)
            buff.write(_struct_I.pack(length))
            for val9 in _v31.segment_attribute_xy:
              _x = val9.segment_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v29.disabled_exists
            buff.write(_get_struct_B().pack(_x))
            _v32 = _v29.enabled
            length = len(_v32.segment_attribute_xy)
            buff.write(_struct_I.pack(length))
            for val9 in _v32.segment_attribute_xy:
              _x = val9.segment_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v29.enabled_exists
            buff.write(_get_struct_B().pack(_x))
            _v33 = _v29.data
            length = len(_v33.lane_attribute_list)
            buff.write(_struct_I.pack(length))
            for val9 in _v33.lane_attribute_list:
              _x = val9
              buff.write(_get_struct_Bh3bh().pack(_x.choice, _x.path_end_point_angle, _x.lane_crown_point_center, _x.lane_crown_point_right, _x.lane_crown_point_left, _x.lane_angle))
              _v34 = val9.speed_limits
              length = len(_v34.speed_limits)
              buff.write(_struct_I.pack(length))
              for val11 in _v34.speed_limits:
                _v35 = val11.type
                _x = _v35.speed_limit_type
                buff.write(_get_struct_B().pack(_x))
                _x = val11.speed
                buff.write(_get_struct_d().pack(_x))
            _x = _v29
            buff.write(_get_struct_BfBfB().pack(_x.data_exists, _x.dWitdh, _x.dWitdh_exists, _x.dElevation, _x.dElevation_exists))
            _x = val6.attributes_exists
            buff.write(_get_struct_B().pack(_x))
          _v36 = _v19.computed
          _x = _v36.reference_lane_id
          buff.write(_get_struct_H().pack(_x))
          _v37 = _v36.offset_x_axis
          _x = _v37
          buff.write(_get_struct_B2h().pack(_x.choice, _x.small, _x.large))
          _v38 = _v36.offset_y_axis
          _x = _v38
          buff.write(_get_struct_B2h().pack(_x.choice, _x.small, _x.large))
          _x = _v36
          buff.write(_get_struct_HBhBhB().pack(_x.rotateXY, _x.rotatexy_exists, _x.scale_x_axis, _x.scale_x_axis_exists, _x.scale_y_axis, _x.scale_y_axis_exists))
          _v39 = val3.connects_to
          length = len(_v39.connect_to_list)
          buff.write(_struct_I.pack(length))
          for val5 in _v39.connect_to_list:
            _v40 = val5.connecting_lane
            _x = _v40.lane
            buff.write(_get_struct_H().pack(_x))
            _v41 = _v40.maneuver
            _x = _v41.allowed_maneuvers
            buff.write(_get_struct_H().pack(_x))
            _x = _v40.maneuver_exists
            buff.write(_get_struct_B().pack(_x))
            _v42 = val5.remote_intersection
            _x = _v42
            buff.write(_get_struct_HBH().pack(_x.region, _x.region_exists, _x.id))
            _x = val5
            buff.write(_get_struct_7B().pack(_x.remote_intersection_exists, _x.signal_group, _x.signal_group_exists, _x.user_class, _x.user_class_exists, _x.connection_id, _x.connection_id_exists))
          _x = val3.connects_to_exists
          buff.write(_get_struct_B().pack(_x))
          _v43 = val3.overlay_lane_list
          length = len(_v43.overlay_lane_list)
          buff.write(_struct_I.pack(length))
          pattern = '<%sH'%length
          buff.write(struct.Struct(pattern).pack(*_v43.overlay_lane_list))
          _x = val3.overlay_lane_list_exists
          buff.write(_get_struct_B().pack(_x))
        _v44 = val1.preempt_priority_data
        length = len(_v44.preempt_priority_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v44.preempt_priority_list:
          pass
        _x = val1.preempt_priority_data_exists
        buff.write(_get_struct_B().pack(_x))
      _x = self.intersections_exists
      buff.write(_get_struct_B().pack(_x))
      length = len(self.road_segments.road_segment_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.road_segments.road_segment_list:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.name_exists
        buff.write(_get_struct_B().pack(_x))
        _v45 = val1.id
        _x = _v45
        buff.write(_get_struct_HBHB().pack(_x.region, _x.region_exists, _x.id, _x.id_exists))
        _x = val1.revision
        buff.write(_get_struct_B().pack(_x))
        _v46 = val1.ref_point
        _x = _v46
        buff.write(_get_struct_2dfB().pack(_x.latitude, _x.longitude, _x.elevation, _x.elevation_exists))
        _x = val1
        buff.write(_get_struct_HB().pack(_x.lane_width, _x.lane_width_exists))
        _v47 = val1.speed_limits
        length = len(_v47.speed_limits)
        buff.write(_struct_I.pack(length))
        for val3 in _v47.speed_limits:
          _v48 = val3.type
          _x = _v48.speed_limit_type
          buff.write(_get_struct_B().pack(_x))
          _x = val3.speed
          buff.write(_get_struct_d().pack(_x))
        _x = val1.speed_limits_exists
        buff.write(_get_struct_B().pack(_x))
        _v49 = val1.road_lane_set
        length = len(_v49.road_lane_set_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v49.road_lane_set_list:
          _x = val3.lane_id
          buff.write(_get_struct_B().pack(_x))
          _x = val3.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_5B().pack(_x.name_exists, _x.ingress_approach, _x.ingress_approach_exists, _x.egress_approach, _x.egress_approach_exists))
          _v50 = val3.lane_attributes
          _v51 = _v50.directional_use
          _x = _v51.lane_direction
          buff.write(_get_struct_B().pack(_x))
          _v52 = _v50.shared_with
          _x = _v52.lane_sharing
          buff.write(_get_struct_H().pack(_x))
          _v53 = _v50.laneType
          _x = _v53.choice
          buff.write(_get_struct_B().pack(_x))
          _v54 = _v53.vehicle
          _x = _v54.lane_attributes_vehicle
          buff.write(_get_struct_B().pack(_x))
          _v55 = _v53.crosswalk
          _x = _v55.lane_attributes_crosswalk
          buff.write(_get_struct_H().pack(_x))
          _v56 = _v53.bikeLane
          _x = _v56.lane_attributes_bike
          buff.write(_get_struct_H().pack(_x))
          _v57 = _v53.sidewalk
          _x = _v57.lane_attributes_sidewalk
          buff.write(_get_struct_H().pack(_x))
          _v58 = _v53.median
          _x = _v58.lane_attributes_barrier
          buff.write(_get_struct_H().pack(_x))
          _v59 = _v53.striping
          _x = _v59.lane_attributes_striping
          buff.write(_get_struct_H().pack(_x))
          _v60 = _v53.trackedVehicle
          _x = _v60.lane_attributes_trackedvehicle
          buff.write(_get_struct_H().pack(_x))
          _v61 = _v53.parking
          _x = _v61.lane_attributes_parking
          buff.write(_get_struct_H().pack(_x))
          _v62 = val3.maneuvers
          _x = _v62.allowed_maneuvers
          buff.write(_get_struct_H().pack(_x))
          _x = val3.maneuvers_exists
          buff.write(_get_struct_B().pack(_x))
          _v63 = val3.node_list
          _x = _v63.choice
          buff.write(_get_struct_B().pack(_x))
          _v64 = _v63.nodes
          length = len(_v64.node_set_xy)
          buff.write(_struct_I.pack(length))
          for val6 in _v64.node_set_xy:
            _v65 = val6.delta
            _x = _v65.choice
            buff.write(_get_struct_B().pack(_x))
            _v66 = _v65.node_xy1
            _x = _v66
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v67 = _v65.node_xy2
            _x = _v67
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v68 = _v65.node_xy3
            _x = _v68
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v69 = _v65.node_xy4
            _x = _v69
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v70 = _v65.node_xy5
            _x = _v70
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v71 = _v65.node_xy6
            _x = _v71
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v72 = _v65.node_latlon
            _x = _v72
            buff.write(_get_struct_2i().pack(_x.longitude, _x.latitude))
            _v73 = val6.attributes
            _v74 = _v73.local_node
            length = len(_v74.node_attribute_xy_List)
            buff.write(_struct_I.pack(length))
            for val9 in _v74.node_attribute_xy_List:
              _x = val9.node_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v73.local_node_exists
            buff.write(_get_struct_B().pack(_x))
            _v75 = _v73.disabled
            length = len(_v75.segment_attribute_xy)
            buff.write(_struct_I.pack(length))
            for val9 in _v75.segment_attribute_xy:
              _x = val9.segment_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v73.disabled_exists
            buff.write(_get_struct_B().pack(_x))
            _v76 = _v73.enabled
            length = len(_v76.segment_attribute_xy)
            buff.write(_struct_I.pack(length))
            for val9 in _v76.segment_attribute_xy:
              _x = val9.segment_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v73.enabled_exists
            buff.write(_get_struct_B().pack(_x))
            _v77 = _v73.data
            length = len(_v77.lane_attribute_list)
            buff.write(_struct_I.pack(length))
            for val9 in _v77.lane_attribute_list:
              _x = val9
              buff.write(_get_struct_Bh3bh().pack(_x.choice, _x.path_end_point_angle, _x.lane_crown_point_center, _x.lane_crown_point_right, _x.lane_crown_point_left, _x.lane_angle))
              _v78 = val9.speed_limits
              length = len(_v78.speed_limits)
              buff.write(_struct_I.pack(length))
              for val11 in _v78.speed_limits:
                _v79 = val11.type
                _x = _v79.speed_limit_type
                buff.write(_get_struct_B().pack(_x))
                _x = val11.speed
                buff.write(_get_struct_d().pack(_x))
            _x = _v73
            buff.write(_get_struct_BfBfB().pack(_x.data_exists, _x.dWitdh, _x.dWitdh_exists, _x.dElevation, _x.dElevation_exists))
            _x = val6.attributes_exists
            buff.write(_get_struct_B().pack(_x))
          _v80 = _v63.computed
          _x = _v80.reference_lane_id
          buff.write(_get_struct_H().pack(_x))
          _v81 = _v80.offset_x_axis
          _x = _v81
          buff.write(_get_struct_B2h().pack(_x.choice, _x.small, _x.large))
          _v82 = _v80.offset_y_axis
          _x = _v82
          buff.write(_get_struct_B2h().pack(_x.choice, _x.small, _x.large))
          _x = _v80
          buff.write(_get_struct_HBhBhB().pack(_x.rotateXY, _x.rotatexy_exists, _x.scale_x_axis, _x.scale_x_axis_exists, _x.scale_y_axis, _x.scale_y_axis_exists))
          _v83 = val3.connects_to
          length = len(_v83.connect_to_list)
          buff.write(_struct_I.pack(length))
          for val5 in _v83.connect_to_list:
            _v84 = val5.connecting_lane
            _x = _v84.lane
            buff.write(_get_struct_H().pack(_x))
            _v85 = _v84.maneuver
            _x = _v85.allowed_maneuvers
            buff.write(_get_struct_H().pack(_x))
            _x = _v84.maneuver_exists
            buff.write(_get_struct_B().pack(_x))
            _v86 = val5.remote_intersection
            _x = _v86
            buff.write(_get_struct_HBH().pack(_x.region, _x.region_exists, _x.id))
            _x = val5
            buff.write(_get_struct_7B().pack(_x.remote_intersection_exists, _x.signal_group, _x.signal_group_exists, _x.user_class, _x.user_class_exists, _x.connection_id, _x.connection_id_exists))
          _x = val3.connects_to_exists
          buff.write(_get_struct_B().pack(_x))
          _v87 = val3.overlay_lane_list
          length = len(_v87.overlay_lane_list)
          buff.write(_struct_I.pack(length))
          pattern = '<%sH'%length
          buff.write(struct.Struct(pattern).pack(*_v87.overlay_lane_list))
          _x = val3.overlay_lane_list_exists
          buff.write(_get_struct_B().pack(_x))
      _x = self.road_segments_exists
      buff.write(_get_struct_B().pack(_x))
      _x = self.data_parameters.process_method
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.data_parameters.process_agency
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.data_parameters.last_checked_date
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.data_parameters.geoid_used
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.data_parameters_exists
      buff.write(_get_struct_B().pack(_x))
      length = len(self.restriction_list.restriction_class_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.restriction_list.restriction_class_list:
        _x = val1.id
        buff.write(_get_struct_B().pack(_x))
      _x = self.restriction_list_exists
      buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.layer_type is None:
        self.layer_type = j2735_msgs.msg.LayerType()
      if self.intersections is None:
        self.intersections = None
      if self.road_segments is None:
        self.road_segments = j2735_msgs.msg.RoadSegmentList()
      if self.data_parameters is None:
        self.data_parameters = j2735_msgs.msg.DataParameters()
      if self.restriction_list is None:
        self.restriction_list = j2735_msgs.msg.RestrictionClassList()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 9
      (_x.time_stamp, _x.time_stamp_exists, _x.msg_issue_revision, _x.layer_type.layer_type, _x.layer_id, _x.layer_id_exists,) = _get_struct_I5B().unpack(str[start:end])
      self.time_stamp_exists = bool(self.time_stamp_exists)
      self.layer_id_exists = bool(self.layer_id_exists)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.intersections = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.IntersectionGeometry()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        start = end
        end += 1
        (val1.name_exists,) = _get_struct_B().unpack(str[start:end])
        val1.name_exists = bool(val1.name_exists)
        _v88 = val1.id
        _x = _v88
        start = end
        end += 5
        (_x.region, _x.region_exists, _x.id,) = _get_struct_HBH().unpack(str[start:end])
        _v88.region_exists = bool(_v88.region_exists)
        start = end
        end += 1
        (val1.revision,) = _get_struct_B().unpack(str[start:end])
        _v89 = val1.ref_point
        _x = _v89
        start = end
        end += 21
        (_x.latitude, _x.longitude, _x.elevation, _x.elevation_exists,) = _get_struct_2dfB().unpack(str[start:end])
        _v89.elevation_exists = bool(_v89.elevation_exists)
        _x = val1
        start = end
        end += 3
        (_x.lane_width, _x.lane_width_exists,) = _get_struct_HB().unpack(str[start:end])
        val1.lane_width_exists = bool(val1.lane_width_exists)
        _v90 = val1.speed_limits
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v90.speed_limits = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.RegulatorySpeedLimit()
          _v91 = val3.type
          start = end
          end += 1
          (_v91.speed_limit_type,) = _get_struct_B().unpack(str[start:end])
          start = end
          end += 8
          (val3.speed,) = _get_struct_d().unpack(str[start:end])
          _v90.speed_limits.append(val3)
        start = end
        end += 1
        (val1.speed_limits_exists,) = _get_struct_B().unpack(str[start:end])
        val1.speed_limits_exists = bool(val1.speed_limits_exists)
        _v92 = val1.lane_set
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v92.lane_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.GenericLane()
          start = end
          end += 1
          (val3.lane_id,) = _get_struct_B().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.name = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.name = str[start:end]
          _x = val3
          start = end
          end += 5
          (_x.name_exists, _x.ingress_approach, _x.ingress_approach_exists, _x.egress_approach, _x.egress_approach_exists,) = _get_struct_5B().unpack(str[start:end])
          val3.name_exists = bool(val3.name_exists)
          val3.ingress_approach_exists = bool(val3.ingress_approach_exists)
          val3.egress_approach_exists = bool(val3.egress_approach_exists)
          _v93 = val3.lane_attributes
          _v94 = _v93.directional_use
          start = end
          end += 1
          (_v94.lane_direction,) = _get_struct_B().unpack(str[start:end])
          _v95 = _v93.shared_with
          start = end
          end += 2
          (_v95.lane_sharing,) = _get_struct_H().unpack(str[start:end])
          _v96 = _v93.laneType
          start = end
          end += 1
          (_v96.choice,) = _get_struct_B().unpack(str[start:end])
          _v97 = _v96.vehicle
          start = end
          end += 1
          (_v97.lane_attributes_vehicle,) = _get_struct_B().unpack(str[start:end])
          _v98 = _v96.crosswalk
          start = end
          end += 2
          (_v98.lane_attributes_crosswalk,) = _get_struct_H().unpack(str[start:end])
          _v99 = _v96.bikeLane
          start = end
          end += 2
          (_v99.lane_attributes_bike,) = _get_struct_H().unpack(str[start:end])
          _v100 = _v96.sidewalk
          start = end
          end += 2
          (_v100.lane_attributes_sidewalk,) = _get_struct_H().unpack(str[start:end])
          _v101 = _v96.median
          start = end
          end += 2
          (_v101.lane_attributes_barrier,) = _get_struct_H().unpack(str[start:end])
          _v102 = _v96.striping
          start = end
          end += 2
          (_v102.lane_attributes_striping,) = _get_struct_H().unpack(str[start:end])
          _v103 = _v96.trackedVehicle
          start = end
          end += 2
          (_v103.lane_attributes_trackedvehicle,) = _get_struct_H().unpack(str[start:end])
          _v104 = _v96.parking
          start = end
          end += 2
          (_v104.lane_attributes_parking,) = _get_struct_H().unpack(str[start:end])
          _v105 = val3.maneuvers
          start = end
          end += 2
          (_v105.allowed_maneuvers,) = _get_struct_H().unpack(str[start:end])
          start = end
          end += 1
          (val3.maneuvers_exists,) = _get_struct_B().unpack(str[start:end])
          val3.maneuvers_exists = bool(val3.maneuvers_exists)
          _v106 = val3.node_list
          start = end
          end += 1
          (_v106.choice,) = _get_struct_B().unpack(str[start:end])
          _v107 = _v106.nodes
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v107.node_set_xy = []
          for i in range(0, length):
            val6 = j2735_msgs.msg.NodeXY()
            _v108 = val6.delta
            start = end
            end += 1
            (_v108.choice,) = _get_struct_B().unpack(str[start:end])
            _v109 = _v108.node_xy1
            _x = _v109
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v110 = _v108.node_xy2
            _x = _v110
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v111 = _v108.node_xy3
            _x = _v111
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v112 = _v108.node_xy4
            _x = _v112
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v113 = _v108.node_xy5
            _x = _v113
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v114 = _v108.node_xy6
            _x = _v114
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v115 = _v108.node_latlon
            _x = _v115
            start = end
            end += 8
            (_x.longitude, _x.latitude,) = _get_struct_2i().unpack(str[start:end])
            _v116 = val6.attributes
            _v117 = _v116.local_node
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v117.node_attribute_xy_List = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.NodeAttributeXY()
              start = end
              end += 1
              (val9.node_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v117.node_attribute_xy_List.append(val9)
            start = end
            end += 1
            (_v116.local_node_exists,) = _get_struct_B().unpack(str[start:end])
            _v116.local_node_exists = bool(_v116.local_node_exists)
            _v118 = _v116.disabled
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v118.segment_attribute_xy = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.SegmentAttributeXY()
              start = end
              end += 1
              (val9.segment_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v118.segment_attribute_xy.append(val9)
            start = end
            end += 1
            (_v116.disabled_exists,) = _get_struct_B().unpack(str[start:end])
            _v116.disabled_exists = bool(_v116.disabled_exists)
            _v119 = _v116.enabled
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v119.segment_attribute_xy = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.SegmentAttributeXY()
              start = end
              end += 1
              (val9.segment_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v119.segment_attribute_xy.append(val9)
            start = end
            end += 1
            (_v116.enabled_exists,) = _get_struct_B().unpack(str[start:end])
            _v116.enabled_exists = bool(_v116.enabled_exists)
            _v120 = _v116.data
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v120.lane_attribute_list = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.LaneDataAttribute()
              _x = val9
              start = end
              end += 8
              (_x.choice, _x.path_end_point_angle, _x.lane_crown_point_center, _x.lane_crown_point_right, _x.lane_crown_point_left, _x.lane_angle,) = _get_struct_Bh3bh().unpack(str[start:end])
              _v121 = val9.speed_limits
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              _v121.speed_limits = []
              for i in range(0, length):
                val11 = j2735_msgs.msg.RegulatorySpeedLimit()
                _v122 = val11.type
                start = end
                end += 1
                (_v122.speed_limit_type,) = _get_struct_B().unpack(str[start:end])
                start = end
                end += 8
                (val11.speed,) = _get_struct_d().unpack(str[start:end])
                _v121.speed_limits.append(val11)
              _v120.lane_attribute_list.append(val9)
            _x = _v116
            start = end
            end += 11
            (_x.data_exists, _x.dWitdh, _x.dWitdh_exists, _x.dElevation, _x.dElevation_exists,) = _get_struct_BfBfB().unpack(str[start:end])
            _v116.data_exists = bool(_v116.data_exists)
            _v116.dWitdh_exists = bool(_v116.dWitdh_exists)
            _v116.dElevation_exists = bool(_v116.dElevation_exists)
            start = end
            end += 1
            (val6.attributes_exists,) = _get_struct_B().unpack(str[start:end])
            val6.attributes_exists = bool(val6.attributes_exists)
            _v107.node_set_xy.append(val6)
          _v123 = _v106.computed
          start = end
          end += 2
          (_v123.reference_lane_id,) = _get_struct_H().unpack(str[start:end])
          _v124 = _v123.offset_x_axis
          _x = _v124
          start = end
          end += 5
          (_x.choice, _x.small, _x.large,) = _get_struct_B2h().unpack(str[start:end])
          _v125 = _v123.offset_y_axis
          _x = _v125
          start = end
          end += 5
          (_x.choice, _x.small, _x.large,) = _get_struct_B2h().unpack(str[start:end])
          _x = _v123
          start = end
          end += 9
          (_x.rotateXY, _x.rotatexy_exists, _x.scale_x_axis, _x.scale_x_axis_exists, _x.scale_y_axis, _x.scale_y_axis_exists,) = _get_struct_HBhBhB().unpack(str[start:end])
          _v123.rotatexy_exists = bool(_v123.rotatexy_exists)
          _v123.scale_x_axis_exists = bool(_v123.scale_x_axis_exists)
          _v123.scale_y_axis_exists = bool(_v123.scale_y_axis_exists)
          _v126 = val3.connects_to
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v126.connect_to_list = []
          for i in range(0, length):
            val5 = j2735_msgs.msg.Connection()
            _v127 = val5.connecting_lane
            start = end
            end += 2
            (_v127.lane,) = _get_struct_H().unpack(str[start:end])
            _v128 = _v127.maneuver
            start = end
            end += 2
            (_v128.allowed_maneuvers,) = _get_struct_H().unpack(str[start:end])
            start = end
            end += 1
            (_v127.maneuver_exists,) = _get_struct_B().unpack(str[start:end])
            _v127.maneuver_exists = bool(_v127.maneuver_exists)
            _v129 = val5.remote_intersection
            _x = _v129
            start = end
            end += 5
            (_x.region, _x.region_exists, _x.id,) = _get_struct_HBH().unpack(str[start:end])
            _v129.region_exists = bool(_v129.region_exists)
            _x = val5
            start = end
            end += 7
            (_x.remote_intersection_exists, _x.signal_group, _x.signal_group_exists, _x.user_class, _x.user_class_exists, _x.connection_id, _x.connection_id_exists,) = _get_struct_7B().unpack(str[start:end])
            val5.remote_intersection_exists = bool(val5.remote_intersection_exists)
            val5.signal_group_exists = bool(val5.signal_group_exists)
            val5.user_class_exists = bool(val5.user_class_exists)
            val5.connection_id_exists = bool(val5.connection_id_exists)
            _v126.connect_to_list.append(val5)
          start = end
          end += 1
          (val3.connects_to_exists,) = _get_struct_B().unpack(str[start:end])
          val3.connects_to_exists = bool(val3.connects_to_exists)
          _v130 = val3.overlay_lane_list
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sH'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v130.overlay_lane_list = s.unpack(str[start:end])
          start = end
          end += 1
          (val3.overlay_lane_list_exists,) = _get_struct_B().unpack(str[start:end])
          val3.overlay_lane_list_exists = bool(val3.overlay_lane_list_exists)
          _v92.lane_list.append(val3)
        _v131 = val1.preempt_priority_data
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v131.preempt_priority_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.SignalControlZone()
          _v131.preempt_priority_list.append(val3)
        start = end
        end += 1
        (val1.preempt_priority_data_exists,) = _get_struct_B().unpack(str[start:end])
        val1.preempt_priority_data_exists = bool(val1.preempt_priority_data_exists)
        self.intersections.append(val1)
      start = end
      end += 1
      (self.intersections_exists,) = _get_struct_B().unpack(str[start:end])
      self.intersections_exists = bool(self.intersections_exists)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.road_segments.road_segment_list = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.RoadSegment()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        start = end
        end += 1
        (val1.name_exists,) = _get_struct_B().unpack(str[start:end])
        val1.name_exists = bool(val1.name_exists)
        _v132 = val1.id
        _x = _v132
        start = end
        end += 6
        (_x.region, _x.region_exists, _x.id, _x.id_exists,) = _get_struct_HBHB().unpack(str[start:end])
        _v132.region_exists = bool(_v132.region_exists)
        _v132.id_exists = bool(_v132.id_exists)
        start = end
        end += 1
        (val1.revision,) = _get_struct_B().unpack(str[start:end])
        _v133 = val1.ref_point
        _x = _v133
        start = end
        end += 21
        (_x.latitude, _x.longitude, _x.elevation, _x.elevation_exists,) = _get_struct_2dfB().unpack(str[start:end])
        _v133.elevation_exists = bool(_v133.elevation_exists)
        _x = val1
        start = end
        end += 3
        (_x.lane_width, _x.lane_width_exists,) = _get_struct_HB().unpack(str[start:end])
        val1.lane_width_exists = bool(val1.lane_width_exists)
        _v134 = val1.speed_limits
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v134.speed_limits = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.RegulatorySpeedLimit()
          _v135 = val3.type
          start = end
          end += 1
          (_v135.speed_limit_type,) = _get_struct_B().unpack(str[start:end])
          start = end
          end += 8
          (val3.speed,) = _get_struct_d().unpack(str[start:end])
          _v134.speed_limits.append(val3)
        start = end
        end += 1
        (val1.speed_limits_exists,) = _get_struct_B().unpack(str[start:end])
        val1.speed_limits_exists = bool(val1.speed_limits_exists)
        _v136 = val1.road_lane_set
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v136.road_lane_set_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.GenericLane()
          start = end
          end += 1
          (val3.lane_id,) = _get_struct_B().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.name = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.name = str[start:end]
          _x = val3
          start = end
          end += 5
          (_x.name_exists, _x.ingress_approach, _x.ingress_approach_exists, _x.egress_approach, _x.egress_approach_exists,) = _get_struct_5B().unpack(str[start:end])
          val3.name_exists = bool(val3.name_exists)
          val3.ingress_approach_exists = bool(val3.ingress_approach_exists)
          val3.egress_approach_exists = bool(val3.egress_approach_exists)
          _v137 = val3.lane_attributes
          _v138 = _v137.directional_use
          start = end
          end += 1
          (_v138.lane_direction,) = _get_struct_B().unpack(str[start:end])
          _v139 = _v137.shared_with
          start = end
          end += 2
          (_v139.lane_sharing,) = _get_struct_H().unpack(str[start:end])
          _v140 = _v137.laneType
          start = end
          end += 1
          (_v140.choice,) = _get_struct_B().unpack(str[start:end])
          _v141 = _v140.vehicle
          start = end
          end += 1
          (_v141.lane_attributes_vehicle,) = _get_struct_B().unpack(str[start:end])
          _v142 = _v140.crosswalk
          start = end
          end += 2
          (_v142.lane_attributes_crosswalk,) = _get_struct_H().unpack(str[start:end])
          _v143 = _v140.bikeLane
          start = end
          end += 2
          (_v143.lane_attributes_bike,) = _get_struct_H().unpack(str[start:end])
          _v144 = _v140.sidewalk
          start = end
          end += 2
          (_v144.lane_attributes_sidewalk,) = _get_struct_H().unpack(str[start:end])
          _v145 = _v140.median
          start = end
          end += 2
          (_v145.lane_attributes_barrier,) = _get_struct_H().unpack(str[start:end])
          _v146 = _v140.striping
          start = end
          end += 2
          (_v146.lane_attributes_striping,) = _get_struct_H().unpack(str[start:end])
          _v147 = _v140.trackedVehicle
          start = end
          end += 2
          (_v147.lane_attributes_trackedvehicle,) = _get_struct_H().unpack(str[start:end])
          _v148 = _v140.parking
          start = end
          end += 2
          (_v148.lane_attributes_parking,) = _get_struct_H().unpack(str[start:end])
          _v149 = val3.maneuvers
          start = end
          end += 2
          (_v149.allowed_maneuvers,) = _get_struct_H().unpack(str[start:end])
          start = end
          end += 1
          (val3.maneuvers_exists,) = _get_struct_B().unpack(str[start:end])
          val3.maneuvers_exists = bool(val3.maneuvers_exists)
          _v150 = val3.node_list
          start = end
          end += 1
          (_v150.choice,) = _get_struct_B().unpack(str[start:end])
          _v151 = _v150.nodes
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v151.node_set_xy = []
          for i in range(0, length):
            val6 = j2735_msgs.msg.NodeXY()
            _v152 = val6.delta
            start = end
            end += 1
            (_v152.choice,) = _get_struct_B().unpack(str[start:end])
            _v153 = _v152.node_xy1
            _x = _v153
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v154 = _v152.node_xy2
            _x = _v154
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v155 = _v152.node_xy3
            _x = _v155
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v156 = _v152.node_xy4
            _x = _v156
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v157 = _v152.node_xy5
            _x = _v157
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v158 = _v152.node_xy6
            _x = _v158
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v159 = _v152.node_latlon
            _x = _v159
            start = end
            end += 8
            (_x.longitude, _x.latitude,) = _get_struct_2i().unpack(str[start:end])
            _v160 = val6.attributes
            _v161 = _v160.local_node
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v161.node_attribute_xy_List = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.NodeAttributeXY()
              start = end
              end += 1
              (val9.node_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v161.node_attribute_xy_List.append(val9)
            start = end
            end += 1
            (_v160.local_node_exists,) = _get_struct_B().unpack(str[start:end])
            _v160.local_node_exists = bool(_v160.local_node_exists)
            _v162 = _v160.disabled
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v162.segment_attribute_xy = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.SegmentAttributeXY()
              start = end
              end += 1
              (val9.segment_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v162.segment_attribute_xy.append(val9)
            start = end
            end += 1
            (_v160.disabled_exists,) = _get_struct_B().unpack(str[start:end])
            _v160.disabled_exists = bool(_v160.disabled_exists)
            _v163 = _v160.enabled
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v163.segment_attribute_xy = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.SegmentAttributeXY()
              start = end
              end += 1
              (val9.segment_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v163.segment_attribute_xy.append(val9)
            start = end
            end += 1
            (_v160.enabled_exists,) = _get_struct_B().unpack(str[start:end])
            _v160.enabled_exists = bool(_v160.enabled_exists)
            _v164 = _v160.data
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v164.lane_attribute_list = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.LaneDataAttribute()
              _x = val9
              start = end
              end += 8
              (_x.choice, _x.path_end_point_angle, _x.lane_crown_point_center, _x.lane_crown_point_right, _x.lane_crown_point_left, _x.lane_angle,) = _get_struct_Bh3bh().unpack(str[start:end])
              _v165 = val9.speed_limits
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              _v165.speed_limits = []
              for i in range(0, length):
                val11 = j2735_msgs.msg.RegulatorySpeedLimit()
                _v166 = val11.type
                start = end
                end += 1
                (_v166.speed_limit_type,) = _get_struct_B().unpack(str[start:end])
                start = end
                end += 8
                (val11.speed,) = _get_struct_d().unpack(str[start:end])
                _v165.speed_limits.append(val11)
              _v164.lane_attribute_list.append(val9)
            _x = _v160
            start = end
            end += 11
            (_x.data_exists, _x.dWitdh, _x.dWitdh_exists, _x.dElevation, _x.dElevation_exists,) = _get_struct_BfBfB().unpack(str[start:end])
            _v160.data_exists = bool(_v160.data_exists)
            _v160.dWitdh_exists = bool(_v160.dWitdh_exists)
            _v160.dElevation_exists = bool(_v160.dElevation_exists)
            start = end
            end += 1
            (val6.attributes_exists,) = _get_struct_B().unpack(str[start:end])
            val6.attributes_exists = bool(val6.attributes_exists)
            _v151.node_set_xy.append(val6)
          _v167 = _v150.computed
          start = end
          end += 2
          (_v167.reference_lane_id,) = _get_struct_H().unpack(str[start:end])
          _v168 = _v167.offset_x_axis
          _x = _v168
          start = end
          end += 5
          (_x.choice, _x.small, _x.large,) = _get_struct_B2h().unpack(str[start:end])
          _v169 = _v167.offset_y_axis
          _x = _v169
          start = end
          end += 5
          (_x.choice, _x.small, _x.large,) = _get_struct_B2h().unpack(str[start:end])
          _x = _v167
          start = end
          end += 9
          (_x.rotateXY, _x.rotatexy_exists, _x.scale_x_axis, _x.scale_x_axis_exists, _x.scale_y_axis, _x.scale_y_axis_exists,) = _get_struct_HBhBhB().unpack(str[start:end])
          _v167.rotatexy_exists = bool(_v167.rotatexy_exists)
          _v167.scale_x_axis_exists = bool(_v167.scale_x_axis_exists)
          _v167.scale_y_axis_exists = bool(_v167.scale_y_axis_exists)
          _v170 = val3.connects_to
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v170.connect_to_list = []
          for i in range(0, length):
            val5 = j2735_msgs.msg.Connection()
            _v171 = val5.connecting_lane
            start = end
            end += 2
            (_v171.lane,) = _get_struct_H().unpack(str[start:end])
            _v172 = _v171.maneuver
            start = end
            end += 2
            (_v172.allowed_maneuvers,) = _get_struct_H().unpack(str[start:end])
            start = end
            end += 1
            (_v171.maneuver_exists,) = _get_struct_B().unpack(str[start:end])
            _v171.maneuver_exists = bool(_v171.maneuver_exists)
            _v173 = val5.remote_intersection
            _x = _v173
            start = end
            end += 5
            (_x.region, _x.region_exists, _x.id,) = _get_struct_HBH().unpack(str[start:end])
            _v173.region_exists = bool(_v173.region_exists)
            _x = val5
            start = end
            end += 7
            (_x.remote_intersection_exists, _x.signal_group, _x.signal_group_exists, _x.user_class, _x.user_class_exists, _x.connection_id, _x.connection_id_exists,) = _get_struct_7B().unpack(str[start:end])
            val5.remote_intersection_exists = bool(val5.remote_intersection_exists)
            val5.signal_group_exists = bool(val5.signal_group_exists)
            val5.user_class_exists = bool(val5.user_class_exists)
            val5.connection_id_exists = bool(val5.connection_id_exists)
            _v170.connect_to_list.append(val5)
          start = end
          end += 1
          (val3.connects_to_exists,) = _get_struct_B().unpack(str[start:end])
          val3.connects_to_exists = bool(val3.connects_to_exists)
          _v174 = val3.overlay_lane_list
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sH'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v174.overlay_lane_list = s.unpack(str[start:end])
          start = end
          end += 1
          (val3.overlay_lane_list_exists,) = _get_struct_B().unpack(str[start:end])
          val3.overlay_lane_list_exists = bool(val3.overlay_lane_list_exists)
          _v136.road_lane_set_list.append(val3)
        self.road_segments.road_segment_list.append(val1)
      start = end
      end += 1
      (self.road_segments_exists,) = _get_struct_B().unpack(str[start:end])
      self.road_segments_exists = bool(self.road_segments_exists)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.data_parameters.process_method = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.data_parameters.process_method = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.data_parameters.process_agency = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.data_parameters.process_agency = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.data_parameters.last_checked_date = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.data_parameters.last_checked_date = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.data_parameters.geoid_used = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.data_parameters.geoid_used = str[start:end]
      start = end
      end += 1
      (self.data_parameters_exists,) = _get_struct_B().unpack(str[start:end])
      self.data_parameters_exists = bool(self.data_parameters_exists)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.restriction_list.restriction_class_list = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.RestrictionClassAssignment()
        start = end
        end += 1
        (val1.id,) = _get_struct_B().unpack(str[start:end])
        self.restriction_list.restriction_class_list.append(val1)
      start = end
      end += 1
      (self.restriction_list_exists,) = _get_struct_B().unpack(str[start:end])
      self.restriction_list_exists = bool(self.restriction_list_exists)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_I5B().pack(_x.time_stamp, _x.time_stamp_exists, _x.msg_issue_revision, _x.layer_type.layer_type, _x.layer_id, _x.layer_id_exists))
      length = len(self.intersections)
      buff.write(_struct_I.pack(length))
      for val1 in self.intersections:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.name_exists
        buff.write(_get_struct_B().pack(_x))
        _v175 = val1.id
        _x = _v175
        buff.write(_get_struct_HBH().pack(_x.region, _x.region_exists, _x.id))
        _x = val1.revision
        buff.write(_get_struct_B().pack(_x))
        _v176 = val1.ref_point
        _x = _v176
        buff.write(_get_struct_2dfB().pack(_x.latitude, _x.longitude, _x.elevation, _x.elevation_exists))
        _x = val1
        buff.write(_get_struct_HB().pack(_x.lane_width, _x.lane_width_exists))
        _v177 = val1.speed_limits
        length = len(_v177.speed_limits)
        buff.write(_struct_I.pack(length))
        for val3 in _v177.speed_limits:
          _v178 = val3.type
          _x = _v178.speed_limit_type
          buff.write(_get_struct_B().pack(_x))
          _x = val3.speed
          buff.write(_get_struct_d().pack(_x))
        _x = val1.speed_limits_exists
        buff.write(_get_struct_B().pack(_x))
        _v179 = val1.lane_set
        length = len(_v179.lane_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v179.lane_list:
          _x = val3.lane_id
          buff.write(_get_struct_B().pack(_x))
          _x = val3.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_5B().pack(_x.name_exists, _x.ingress_approach, _x.ingress_approach_exists, _x.egress_approach, _x.egress_approach_exists))
          _v180 = val3.lane_attributes
          _v181 = _v180.directional_use
          _x = _v181.lane_direction
          buff.write(_get_struct_B().pack(_x))
          _v182 = _v180.shared_with
          _x = _v182.lane_sharing
          buff.write(_get_struct_H().pack(_x))
          _v183 = _v180.laneType
          _x = _v183.choice
          buff.write(_get_struct_B().pack(_x))
          _v184 = _v183.vehicle
          _x = _v184.lane_attributes_vehicle
          buff.write(_get_struct_B().pack(_x))
          _v185 = _v183.crosswalk
          _x = _v185.lane_attributes_crosswalk
          buff.write(_get_struct_H().pack(_x))
          _v186 = _v183.bikeLane
          _x = _v186.lane_attributes_bike
          buff.write(_get_struct_H().pack(_x))
          _v187 = _v183.sidewalk
          _x = _v187.lane_attributes_sidewalk
          buff.write(_get_struct_H().pack(_x))
          _v188 = _v183.median
          _x = _v188.lane_attributes_barrier
          buff.write(_get_struct_H().pack(_x))
          _v189 = _v183.striping
          _x = _v189.lane_attributes_striping
          buff.write(_get_struct_H().pack(_x))
          _v190 = _v183.trackedVehicle
          _x = _v190.lane_attributes_trackedvehicle
          buff.write(_get_struct_H().pack(_x))
          _v191 = _v183.parking
          _x = _v191.lane_attributes_parking
          buff.write(_get_struct_H().pack(_x))
          _v192 = val3.maneuvers
          _x = _v192.allowed_maneuvers
          buff.write(_get_struct_H().pack(_x))
          _x = val3.maneuvers_exists
          buff.write(_get_struct_B().pack(_x))
          _v193 = val3.node_list
          _x = _v193.choice
          buff.write(_get_struct_B().pack(_x))
          _v194 = _v193.nodes
          length = len(_v194.node_set_xy)
          buff.write(_struct_I.pack(length))
          for val6 in _v194.node_set_xy:
            _v195 = val6.delta
            _x = _v195.choice
            buff.write(_get_struct_B().pack(_x))
            _v196 = _v195.node_xy1
            _x = _v196
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v197 = _v195.node_xy2
            _x = _v197
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v198 = _v195.node_xy3
            _x = _v198
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v199 = _v195.node_xy4
            _x = _v199
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v200 = _v195.node_xy5
            _x = _v200
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v201 = _v195.node_xy6
            _x = _v201
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v202 = _v195.node_latlon
            _x = _v202
            buff.write(_get_struct_2i().pack(_x.longitude, _x.latitude))
            _v203 = val6.attributes
            _v204 = _v203.local_node
            length = len(_v204.node_attribute_xy_List)
            buff.write(_struct_I.pack(length))
            for val9 in _v204.node_attribute_xy_List:
              _x = val9.node_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v203.local_node_exists
            buff.write(_get_struct_B().pack(_x))
            _v205 = _v203.disabled
            length = len(_v205.segment_attribute_xy)
            buff.write(_struct_I.pack(length))
            for val9 in _v205.segment_attribute_xy:
              _x = val9.segment_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v203.disabled_exists
            buff.write(_get_struct_B().pack(_x))
            _v206 = _v203.enabled
            length = len(_v206.segment_attribute_xy)
            buff.write(_struct_I.pack(length))
            for val9 in _v206.segment_attribute_xy:
              _x = val9.segment_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v203.enabled_exists
            buff.write(_get_struct_B().pack(_x))
            _v207 = _v203.data
            length = len(_v207.lane_attribute_list)
            buff.write(_struct_I.pack(length))
            for val9 in _v207.lane_attribute_list:
              _x = val9
              buff.write(_get_struct_Bh3bh().pack(_x.choice, _x.path_end_point_angle, _x.lane_crown_point_center, _x.lane_crown_point_right, _x.lane_crown_point_left, _x.lane_angle))
              _v208 = val9.speed_limits
              length = len(_v208.speed_limits)
              buff.write(_struct_I.pack(length))
              for val11 in _v208.speed_limits:
                _v209 = val11.type
                _x = _v209.speed_limit_type
                buff.write(_get_struct_B().pack(_x))
                _x = val11.speed
                buff.write(_get_struct_d().pack(_x))
            _x = _v203
            buff.write(_get_struct_BfBfB().pack(_x.data_exists, _x.dWitdh, _x.dWitdh_exists, _x.dElevation, _x.dElevation_exists))
            _x = val6.attributes_exists
            buff.write(_get_struct_B().pack(_x))
          _v210 = _v193.computed
          _x = _v210.reference_lane_id
          buff.write(_get_struct_H().pack(_x))
          _v211 = _v210.offset_x_axis
          _x = _v211
          buff.write(_get_struct_B2h().pack(_x.choice, _x.small, _x.large))
          _v212 = _v210.offset_y_axis
          _x = _v212
          buff.write(_get_struct_B2h().pack(_x.choice, _x.small, _x.large))
          _x = _v210
          buff.write(_get_struct_HBhBhB().pack(_x.rotateXY, _x.rotatexy_exists, _x.scale_x_axis, _x.scale_x_axis_exists, _x.scale_y_axis, _x.scale_y_axis_exists))
          _v213 = val3.connects_to
          length = len(_v213.connect_to_list)
          buff.write(_struct_I.pack(length))
          for val5 in _v213.connect_to_list:
            _v214 = val5.connecting_lane
            _x = _v214.lane
            buff.write(_get_struct_H().pack(_x))
            _v215 = _v214.maneuver
            _x = _v215.allowed_maneuvers
            buff.write(_get_struct_H().pack(_x))
            _x = _v214.maneuver_exists
            buff.write(_get_struct_B().pack(_x))
            _v216 = val5.remote_intersection
            _x = _v216
            buff.write(_get_struct_HBH().pack(_x.region, _x.region_exists, _x.id))
            _x = val5
            buff.write(_get_struct_7B().pack(_x.remote_intersection_exists, _x.signal_group, _x.signal_group_exists, _x.user_class, _x.user_class_exists, _x.connection_id, _x.connection_id_exists))
          _x = val3.connects_to_exists
          buff.write(_get_struct_B().pack(_x))
          _v217 = val3.overlay_lane_list
          length = len(_v217.overlay_lane_list)
          buff.write(_struct_I.pack(length))
          pattern = '<%sH'%length
          buff.write(_v217.overlay_lane_list.tostring())
          _x = val3.overlay_lane_list_exists
          buff.write(_get_struct_B().pack(_x))
        _v218 = val1.preempt_priority_data
        length = len(_v218.preempt_priority_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v218.preempt_priority_list:
          pass
        _x = val1.preempt_priority_data_exists
        buff.write(_get_struct_B().pack(_x))
      _x = self.intersections_exists
      buff.write(_get_struct_B().pack(_x))
      length = len(self.road_segments.road_segment_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.road_segments.road_segment_list:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.name_exists
        buff.write(_get_struct_B().pack(_x))
        _v219 = val1.id
        _x = _v219
        buff.write(_get_struct_HBHB().pack(_x.region, _x.region_exists, _x.id, _x.id_exists))
        _x = val1.revision
        buff.write(_get_struct_B().pack(_x))
        _v220 = val1.ref_point
        _x = _v220
        buff.write(_get_struct_2dfB().pack(_x.latitude, _x.longitude, _x.elevation, _x.elevation_exists))
        _x = val1
        buff.write(_get_struct_HB().pack(_x.lane_width, _x.lane_width_exists))
        _v221 = val1.speed_limits
        length = len(_v221.speed_limits)
        buff.write(_struct_I.pack(length))
        for val3 in _v221.speed_limits:
          _v222 = val3.type
          _x = _v222.speed_limit_type
          buff.write(_get_struct_B().pack(_x))
          _x = val3.speed
          buff.write(_get_struct_d().pack(_x))
        _x = val1.speed_limits_exists
        buff.write(_get_struct_B().pack(_x))
        _v223 = val1.road_lane_set
        length = len(_v223.road_lane_set_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v223.road_lane_set_list:
          _x = val3.lane_id
          buff.write(_get_struct_B().pack(_x))
          _x = val3.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val3
          buff.write(_get_struct_5B().pack(_x.name_exists, _x.ingress_approach, _x.ingress_approach_exists, _x.egress_approach, _x.egress_approach_exists))
          _v224 = val3.lane_attributes
          _v225 = _v224.directional_use
          _x = _v225.lane_direction
          buff.write(_get_struct_B().pack(_x))
          _v226 = _v224.shared_with
          _x = _v226.lane_sharing
          buff.write(_get_struct_H().pack(_x))
          _v227 = _v224.laneType
          _x = _v227.choice
          buff.write(_get_struct_B().pack(_x))
          _v228 = _v227.vehicle
          _x = _v228.lane_attributes_vehicle
          buff.write(_get_struct_B().pack(_x))
          _v229 = _v227.crosswalk
          _x = _v229.lane_attributes_crosswalk
          buff.write(_get_struct_H().pack(_x))
          _v230 = _v227.bikeLane
          _x = _v230.lane_attributes_bike
          buff.write(_get_struct_H().pack(_x))
          _v231 = _v227.sidewalk
          _x = _v231.lane_attributes_sidewalk
          buff.write(_get_struct_H().pack(_x))
          _v232 = _v227.median
          _x = _v232.lane_attributes_barrier
          buff.write(_get_struct_H().pack(_x))
          _v233 = _v227.striping
          _x = _v233.lane_attributes_striping
          buff.write(_get_struct_H().pack(_x))
          _v234 = _v227.trackedVehicle
          _x = _v234.lane_attributes_trackedvehicle
          buff.write(_get_struct_H().pack(_x))
          _v235 = _v227.parking
          _x = _v235.lane_attributes_parking
          buff.write(_get_struct_H().pack(_x))
          _v236 = val3.maneuvers
          _x = _v236.allowed_maneuvers
          buff.write(_get_struct_H().pack(_x))
          _x = val3.maneuvers_exists
          buff.write(_get_struct_B().pack(_x))
          _v237 = val3.node_list
          _x = _v237.choice
          buff.write(_get_struct_B().pack(_x))
          _v238 = _v237.nodes
          length = len(_v238.node_set_xy)
          buff.write(_struct_I.pack(length))
          for val6 in _v238.node_set_xy:
            _v239 = val6.delta
            _x = _v239.choice
            buff.write(_get_struct_B().pack(_x))
            _v240 = _v239.node_xy1
            _x = _v240
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v241 = _v239.node_xy2
            _x = _v241
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v242 = _v239.node_xy3
            _x = _v242
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v243 = _v239.node_xy4
            _x = _v243
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v244 = _v239.node_xy5
            _x = _v244
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v245 = _v239.node_xy6
            _x = _v245
            buff.write(_get_struct_2f().pack(_x.x, _x.y))
            _v246 = _v239.node_latlon
            _x = _v246
            buff.write(_get_struct_2i().pack(_x.longitude, _x.latitude))
            _v247 = val6.attributes
            _v248 = _v247.local_node
            length = len(_v248.node_attribute_xy_List)
            buff.write(_struct_I.pack(length))
            for val9 in _v248.node_attribute_xy_List:
              _x = val9.node_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v247.local_node_exists
            buff.write(_get_struct_B().pack(_x))
            _v249 = _v247.disabled
            length = len(_v249.segment_attribute_xy)
            buff.write(_struct_I.pack(length))
            for val9 in _v249.segment_attribute_xy:
              _x = val9.segment_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v247.disabled_exists
            buff.write(_get_struct_B().pack(_x))
            _v250 = _v247.enabled
            length = len(_v250.segment_attribute_xy)
            buff.write(_struct_I.pack(length))
            for val9 in _v250.segment_attribute_xy:
              _x = val9.segment_attribute_xy
              buff.write(_get_struct_B().pack(_x))
            _x = _v247.enabled_exists
            buff.write(_get_struct_B().pack(_x))
            _v251 = _v247.data
            length = len(_v251.lane_attribute_list)
            buff.write(_struct_I.pack(length))
            for val9 in _v251.lane_attribute_list:
              _x = val9
              buff.write(_get_struct_Bh3bh().pack(_x.choice, _x.path_end_point_angle, _x.lane_crown_point_center, _x.lane_crown_point_right, _x.lane_crown_point_left, _x.lane_angle))
              _v252 = val9.speed_limits
              length = len(_v252.speed_limits)
              buff.write(_struct_I.pack(length))
              for val11 in _v252.speed_limits:
                _v253 = val11.type
                _x = _v253.speed_limit_type
                buff.write(_get_struct_B().pack(_x))
                _x = val11.speed
                buff.write(_get_struct_d().pack(_x))
            _x = _v247
            buff.write(_get_struct_BfBfB().pack(_x.data_exists, _x.dWitdh, _x.dWitdh_exists, _x.dElevation, _x.dElevation_exists))
            _x = val6.attributes_exists
            buff.write(_get_struct_B().pack(_x))
          _v254 = _v237.computed
          _x = _v254.reference_lane_id
          buff.write(_get_struct_H().pack(_x))
          _v255 = _v254.offset_x_axis
          _x = _v255
          buff.write(_get_struct_B2h().pack(_x.choice, _x.small, _x.large))
          _v256 = _v254.offset_y_axis
          _x = _v256
          buff.write(_get_struct_B2h().pack(_x.choice, _x.small, _x.large))
          _x = _v254
          buff.write(_get_struct_HBhBhB().pack(_x.rotateXY, _x.rotatexy_exists, _x.scale_x_axis, _x.scale_x_axis_exists, _x.scale_y_axis, _x.scale_y_axis_exists))
          _v257 = val3.connects_to
          length = len(_v257.connect_to_list)
          buff.write(_struct_I.pack(length))
          for val5 in _v257.connect_to_list:
            _v258 = val5.connecting_lane
            _x = _v258.lane
            buff.write(_get_struct_H().pack(_x))
            _v259 = _v258.maneuver
            _x = _v259.allowed_maneuvers
            buff.write(_get_struct_H().pack(_x))
            _x = _v258.maneuver_exists
            buff.write(_get_struct_B().pack(_x))
            _v260 = val5.remote_intersection
            _x = _v260
            buff.write(_get_struct_HBH().pack(_x.region, _x.region_exists, _x.id))
            _x = val5
            buff.write(_get_struct_7B().pack(_x.remote_intersection_exists, _x.signal_group, _x.signal_group_exists, _x.user_class, _x.user_class_exists, _x.connection_id, _x.connection_id_exists))
          _x = val3.connects_to_exists
          buff.write(_get_struct_B().pack(_x))
          _v261 = val3.overlay_lane_list
          length = len(_v261.overlay_lane_list)
          buff.write(_struct_I.pack(length))
          pattern = '<%sH'%length
          buff.write(_v261.overlay_lane_list.tostring())
          _x = val3.overlay_lane_list_exists
          buff.write(_get_struct_B().pack(_x))
      _x = self.road_segments_exists
      buff.write(_get_struct_B().pack(_x))
      _x = self.data_parameters.process_method
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.data_parameters.process_agency
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.data_parameters.last_checked_date
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.data_parameters.geoid_used
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.data_parameters_exists
      buff.write(_get_struct_B().pack(_x))
      length = len(self.restriction_list.restriction_class_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.restriction_list.restriction_class_list:
        _x = val1.id
        buff.write(_get_struct_B().pack(_x))
      _x = self.restriction_list_exists
      buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.layer_type is None:
        self.layer_type = j2735_msgs.msg.LayerType()
      if self.intersections is None:
        self.intersections = None
      if self.road_segments is None:
        self.road_segments = j2735_msgs.msg.RoadSegmentList()
      if self.data_parameters is None:
        self.data_parameters = j2735_msgs.msg.DataParameters()
      if self.restriction_list is None:
        self.restriction_list = j2735_msgs.msg.RestrictionClassList()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 9
      (_x.time_stamp, _x.time_stamp_exists, _x.msg_issue_revision, _x.layer_type.layer_type, _x.layer_id, _x.layer_id_exists,) = _get_struct_I5B().unpack(str[start:end])
      self.time_stamp_exists = bool(self.time_stamp_exists)
      self.layer_id_exists = bool(self.layer_id_exists)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.intersections = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.IntersectionGeometry()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        start = end
        end += 1
        (val1.name_exists,) = _get_struct_B().unpack(str[start:end])
        val1.name_exists = bool(val1.name_exists)
        _v262 = val1.id
        _x = _v262
        start = end
        end += 5
        (_x.region, _x.region_exists, _x.id,) = _get_struct_HBH().unpack(str[start:end])
        _v262.region_exists = bool(_v262.region_exists)
        start = end
        end += 1
        (val1.revision,) = _get_struct_B().unpack(str[start:end])
        _v263 = val1.ref_point
        _x = _v263
        start = end
        end += 21
        (_x.latitude, _x.longitude, _x.elevation, _x.elevation_exists,) = _get_struct_2dfB().unpack(str[start:end])
        _v263.elevation_exists = bool(_v263.elevation_exists)
        _x = val1
        start = end
        end += 3
        (_x.lane_width, _x.lane_width_exists,) = _get_struct_HB().unpack(str[start:end])
        val1.lane_width_exists = bool(val1.lane_width_exists)
        _v264 = val1.speed_limits
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v264.speed_limits = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.RegulatorySpeedLimit()
          _v265 = val3.type
          start = end
          end += 1
          (_v265.speed_limit_type,) = _get_struct_B().unpack(str[start:end])
          start = end
          end += 8
          (val3.speed,) = _get_struct_d().unpack(str[start:end])
          _v264.speed_limits.append(val3)
        start = end
        end += 1
        (val1.speed_limits_exists,) = _get_struct_B().unpack(str[start:end])
        val1.speed_limits_exists = bool(val1.speed_limits_exists)
        _v266 = val1.lane_set
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v266.lane_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.GenericLane()
          start = end
          end += 1
          (val3.lane_id,) = _get_struct_B().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.name = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.name = str[start:end]
          _x = val3
          start = end
          end += 5
          (_x.name_exists, _x.ingress_approach, _x.ingress_approach_exists, _x.egress_approach, _x.egress_approach_exists,) = _get_struct_5B().unpack(str[start:end])
          val3.name_exists = bool(val3.name_exists)
          val3.ingress_approach_exists = bool(val3.ingress_approach_exists)
          val3.egress_approach_exists = bool(val3.egress_approach_exists)
          _v267 = val3.lane_attributes
          _v268 = _v267.directional_use
          start = end
          end += 1
          (_v268.lane_direction,) = _get_struct_B().unpack(str[start:end])
          _v269 = _v267.shared_with
          start = end
          end += 2
          (_v269.lane_sharing,) = _get_struct_H().unpack(str[start:end])
          _v270 = _v267.laneType
          start = end
          end += 1
          (_v270.choice,) = _get_struct_B().unpack(str[start:end])
          _v271 = _v270.vehicle
          start = end
          end += 1
          (_v271.lane_attributes_vehicle,) = _get_struct_B().unpack(str[start:end])
          _v272 = _v270.crosswalk
          start = end
          end += 2
          (_v272.lane_attributes_crosswalk,) = _get_struct_H().unpack(str[start:end])
          _v273 = _v270.bikeLane
          start = end
          end += 2
          (_v273.lane_attributes_bike,) = _get_struct_H().unpack(str[start:end])
          _v274 = _v270.sidewalk
          start = end
          end += 2
          (_v274.lane_attributes_sidewalk,) = _get_struct_H().unpack(str[start:end])
          _v275 = _v270.median
          start = end
          end += 2
          (_v275.lane_attributes_barrier,) = _get_struct_H().unpack(str[start:end])
          _v276 = _v270.striping
          start = end
          end += 2
          (_v276.lane_attributes_striping,) = _get_struct_H().unpack(str[start:end])
          _v277 = _v270.trackedVehicle
          start = end
          end += 2
          (_v277.lane_attributes_trackedvehicle,) = _get_struct_H().unpack(str[start:end])
          _v278 = _v270.parking
          start = end
          end += 2
          (_v278.lane_attributes_parking,) = _get_struct_H().unpack(str[start:end])
          _v279 = val3.maneuvers
          start = end
          end += 2
          (_v279.allowed_maneuvers,) = _get_struct_H().unpack(str[start:end])
          start = end
          end += 1
          (val3.maneuvers_exists,) = _get_struct_B().unpack(str[start:end])
          val3.maneuvers_exists = bool(val3.maneuvers_exists)
          _v280 = val3.node_list
          start = end
          end += 1
          (_v280.choice,) = _get_struct_B().unpack(str[start:end])
          _v281 = _v280.nodes
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v281.node_set_xy = []
          for i in range(0, length):
            val6 = j2735_msgs.msg.NodeXY()
            _v282 = val6.delta
            start = end
            end += 1
            (_v282.choice,) = _get_struct_B().unpack(str[start:end])
            _v283 = _v282.node_xy1
            _x = _v283
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v284 = _v282.node_xy2
            _x = _v284
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v285 = _v282.node_xy3
            _x = _v285
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v286 = _v282.node_xy4
            _x = _v286
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v287 = _v282.node_xy5
            _x = _v287
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v288 = _v282.node_xy6
            _x = _v288
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v289 = _v282.node_latlon
            _x = _v289
            start = end
            end += 8
            (_x.longitude, _x.latitude,) = _get_struct_2i().unpack(str[start:end])
            _v290 = val6.attributes
            _v291 = _v290.local_node
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v291.node_attribute_xy_List = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.NodeAttributeXY()
              start = end
              end += 1
              (val9.node_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v291.node_attribute_xy_List.append(val9)
            start = end
            end += 1
            (_v290.local_node_exists,) = _get_struct_B().unpack(str[start:end])
            _v290.local_node_exists = bool(_v290.local_node_exists)
            _v292 = _v290.disabled
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v292.segment_attribute_xy = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.SegmentAttributeXY()
              start = end
              end += 1
              (val9.segment_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v292.segment_attribute_xy.append(val9)
            start = end
            end += 1
            (_v290.disabled_exists,) = _get_struct_B().unpack(str[start:end])
            _v290.disabled_exists = bool(_v290.disabled_exists)
            _v293 = _v290.enabled
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v293.segment_attribute_xy = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.SegmentAttributeXY()
              start = end
              end += 1
              (val9.segment_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v293.segment_attribute_xy.append(val9)
            start = end
            end += 1
            (_v290.enabled_exists,) = _get_struct_B().unpack(str[start:end])
            _v290.enabled_exists = bool(_v290.enabled_exists)
            _v294 = _v290.data
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v294.lane_attribute_list = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.LaneDataAttribute()
              _x = val9
              start = end
              end += 8
              (_x.choice, _x.path_end_point_angle, _x.lane_crown_point_center, _x.lane_crown_point_right, _x.lane_crown_point_left, _x.lane_angle,) = _get_struct_Bh3bh().unpack(str[start:end])
              _v295 = val9.speed_limits
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              _v295.speed_limits = []
              for i in range(0, length):
                val11 = j2735_msgs.msg.RegulatorySpeedLimit()
                _v296 = val11.type
                start = end
                end += 1
                (_v296.speed_limit_type,) = _get_struct_B().unpack(str[start:end])
                start = end
                end += 8
                (val11.speed,) = _get_struct_d().unpack(str[start:end])
                _v295.speed_limits.append(val11)
              _v294.lane_attribute_list.append(val9)
            _x = _v290
            start = end
            end += 11
            (_x.data_exists, _x.dWitdh, _x.dWitdh_exists, _x.dElevation, _x.dElevation_exists,) = _get_struct_BfBfB().unpack(str[start:end])
            _v290.data_exists = bool(_v290.data_exists)
            _v290.dWitdh_exists = bool(_v290.dWitdh_exists)
            _v290.dElevation_exists = bool(_v290.dElevation_exists)
            start = end
            end += 1
            (val6.attributes_exists,) = _get_struct_B().unpack(str[start:end])
            val6.attributes_exists = bool(val6.attributes_exists)
            _v281.node_set_xy.append(val6)
          _v297 = _v280.computed
          start = end
          end += 2
          (_v297.reference_lane_id,) = _get_struct_H().unpack(str[start:end])
          _v298 = _v297.offset_x_axis
          _x = _v298
          start = end
          end += 5
          (_x.choice, _x.small, _x.large,) = _get_struct_B2h().unpack(str[start:end])
          _v299 = _v297.offset_y_axis
          _x = _v299
          start = end
          end += 5
          (_x.choice, _x.small, _x.large,) = _get_struct_B2h().unpack(str[start:end])
          _x = _v297
          start = end
          end += 9
          (_x.rotateXY, _x.rotatexy_exists, _x.scale_x_axis, _x.scale_x_axis_exists, _x.scale_y_axis, _x.scale_y_axis_exists,) = _get_struct_HBhBhB().unpack(str[start:end])
          _v297.rotatexy_exists = bool(_v297.rotatexy_exists)
          _v297.scale_x_axis_exists = bool(_v297.scale_x_axis_exists)
          _v297.scale_y_axis_exists = bool(_v297.scale_y_axis_exists)
          _v300 = val3.connects_to
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v300.connect_to_list = []
          for i in range(0, length):
            val5 = j2735_msgs.msg.Connection()
            _v301 = val5.connecting_lane
            start = end
            end += 2
            (_v301.lane,) = _get_struct_H().unpack(str[start:end])
            _v302 = _v301.maneuver
            start = end
            end += 2
            (_v302.allowed_maneuvers,) = _get_struct_H().unpack(str[start:end])
            start = end
            end += 1
            (_v301.maneuver_exists,) = _get_struct_B().unpack(str[start:end])
            _v301.maneuver_exists = bool(_v301.maneuver_exists)
            _v303 = val5.remote_intersection
            _x = _v303
            start = end
            end += 5
            (_x.region, _x.region_exists, _x.id,) = _get_struct_HBH().unpack(str[start:end])
            _v303.region_exists = bool(_v303.region_exists)
            _x = val5
            start = end
            end += 7
            (_x.remote_intersection_exists, _x.signal_group, _x.signal_group_exists, _x.user_class, _x.user_class_exists, _x.connection_id, _x.connection_id_exists,) = _get_struct_7B().unpack(str[start:end])
            val5.remote_intersection_exists = bool(val5.remote_intersection_exists)
            val5.signal_group_exists = bool(val5.signal_group_exists)
            val5.user_class_exists = bool(val5.user_class_exists)
            val5.connection_id_exists = bool(val5.connection_id_exists)
            _v300.connect_to_list.append(val5)
          start = end
          end += 1
          (val3.connects_to_exists,) = _get_struct_B().unpack(str[start:end])
          val3.connects_to_exists = bool(val3.connects_to_exists)
          _v304 = val3.overlay_lane_list
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sH'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v304.overlay_lane_list = numpy.frombuffer(str[start:end], dtype=numpy.uint16, count=length)
          start = end
          end += 1
          (val3.overlay_lane_list_exists,) = _get_struct_B().unpack(str[start:end])
          val3.overlay_lane_list_exists = bool(val3.overlay_lane_list_exists)
          _v266.lane_list.append(val3)
        _v305 = val1.preempt_priority_data
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v305.preempt_priority_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.SignalControlZone()
          _v305.preempt_priority_list.append(val3)
        start = end
        end += 1
        (val1.preempt_priority_data_exists,) = _get_struct_B().unpack(str[start:end])
        val1.preempt_priority_data_exists = bool(val1.preempt_priority_data_exists)
        self.intersections.append(val1)
      start = end
      end += 1
      (self.intersections_exists,) = _get_struct_B().unpack(str[start:end])
      self.intersections_exists = bool(self.intersections_exists)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.road_segments.road_segment_list = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.RoadSegment()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        start = end
        end += 1
        (val1.name_exists,) = _get_struct_B().unpack(str[start:end])
        val1.name_exists = bool(val1.name_exists)
        _v306 = val1.id
        _x = _v306
        start = end
        end += 6
        (_x.region, _x.region_exists, _x.id, _x.id_exists,) = _get_struct_HBHB().unpack(str[start:end])
        _v306.region_exists = bool(_v306.region_exists)
        _v306.id_exists = bool(_v306.id_exists)
        start = end
        end += 1
        (val1.revision,) = _get_struct_B().unpack(str[start:end])
        _v307 = val1.ref_point
        _x = _v307
        start = end
        end += 21
        (_x.latitude, _x.longitude, _x.elevation, _x.elevation_exists,) = _get_struct_2dfB().unpack(str[start:end])
        _v307.elevation_exists = bool(_v307.elevation_exists)
        _x = val1
        start = end
        end += 3
        (_x.lane_width, _x.lane_width_exists,) = _get_struct_HB().unpack(str[start:end])
        val1.lane_width_exists = bool(val1.lane_width_exists)
        _v308 = val1.speed_limits
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v308.speed_limits = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.RegulatorySpeedLimit()
          _v309 = val3.type
          start = end
          end += 1
          (_v309.speed_limit_type,) = _get_struct_B().unpack(str[start:end])
          start = end
          end += 8
          (val3.speed,) = _get_struct_d().unpack(str[start:end])
          _v308.speed_limits.append(val3)
        start = end
        end += 1
        (val1.speed_limits_exists,) = _get_struct_B().unpack(str[start:end])
        val1.speed_limits_exists = bool(val1.speed_limits_exists)
        _v310 = val1.road_lane_set
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v310.road_lane_set_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.GenericLane()
          start = end
          end += 1
          (val3.lane_id,) = _get_struct_B().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.name = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val3.name = str[start:end]
          _x = val3
          start = end
          end += 5
          (_x.name_exists, _x.ingress_approach, _x.ingress_approach_exists, _x.egress_approach, _x.egress_approach_exists,) = _get_struct_5B().unpack(str[start:end])
          val3.name_exists = bool(val3.name_exists)
          val3.ingress_approach_exists = bool(val3.ingress_approach_exists)
          val3.egress_approach_exists = bool(val3.egress_approach_exists)
          _v311 = val3.lane_attributes
          _v312 = _v311.directional_use
          start = end
          end += 1
          (_v312.lane_direction,) = _get_struct_B().unpack(str[start:end])
          _v313 = _v311.shared_with
          start = end
          end += 2
          (_v313.lane_sharing,) = _get_struct_H().unpack(str[start:end])
          _v314 = _v311.laneType
          start = end
          end += 1
          (_v314.choice,) = _get_struct_B().unpack(str[start:end])
          _v315 = _v314.vehicle
          start = end
          end += 1
          (_v315.lane_attributes_vehicle,) = _get_struct_B().unpack(str[start:end])
          _v316 = _v314.crosswalk
          start = end
          end += 2
          (_v316.lane_attributes_crosswalk,) = _get_struct_H().unpack(str[start:end])
          _v317 = _v314.bikeLane
          start = end
          end += 2
          (_v317.lane_attributes_bike,) = _get_struct_H().unpack(str[start:end])
          _v318 = _v314.sidewalk
          start = end
          end += 2
          (_v318.lane_attributes_sidewalk,) = _get_struct_H().unpack(str[start:end])
          _v319 = _v314.median
          start = end
          end += 2
          (_v319.lane_attributes_barrier,) = _get_struct_H().unpack(str[start:end])
          _v320 = _v314.striping
          start = end
          end += 2
          (_v320.lane_attributes_striping,) = _get_struct_H().unpack(str[start:end])
          _v321 = _v314.trackedVehicle
          start = end
          end += 2
          (_v321.lane_attributes_trackedvehicle,) = _get_struct_H().unpack(str[start:end])
          _v322 = _v314.parking
          start = end
          end += 2
          (_v322.lane_attributes_parking,) = _get_struct_H().unpack(str[start:end])
          _v323 = val3.maneuvers
          start = end
          end += 2
          (_v323.allowed_maneuvers,) = _get_struct_H().unpack(str[start:end])
          start = end
          end += 1
          (val3.maneuvers_exists,) = _get_struct_B().unpack(str[start:end])
          val3.maneuvers_exists = bool(val3.maneuvers_exists)
          _v324 = val3.node_list
          start = end
          end += 1
          (_v324.choice,) = _get_struct_B().unpack(str[start:end])
          _v325 = _v324.nodes
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v325.node_set_xy = []
          for i in range(0, length):
            val6 = j2735_msgs.msg.NodeXY()
            _v326 = val6.delta
            start = end
            end += 1
            (_v326.choice,) = _get_struct_B().unpack(str[start:end])
            _v327 = _v326.node_xy1
            _x = _v327
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v328 = _v326.node_xy2
            _x = _v328
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v329 = _v326.node_xy3
            _x = _v329
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v330 = _v326.node_xy4
            _x = _v330
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v331 = _v326.node_xy5
            _x = _v331
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v332 = _v326.node_xy6
            _x = _v332
            start = end
            end += 8
            (_x.x, _x.y,) = _get_struct_2f().unpack(str[start:end])
            _v333 = _v326.node_latlon
            _x = _v333
            start = end
            end += 8
            (_x.longitude, _x.latitude,) = _get_struct_2i().unpack(str[start:end])
            _v334 = val6.attributes
            _v335 = _v334.local_node
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v335.node_attribute_xy_List = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.NodeAttributeXY()
              start = end
              end += 1
              (val9.node_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v335.node_attribute_xy_List.append(val9)
            start = end
            end += 1
            (_v334.local_node_exists,) = _get_struct_B().unpack(str[start:end])
            _v334.local_node_exists = bool(_v334.local_node_exists)
            _v336 = _v334.disabled
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v336.segment_attribute_xy = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.SegmentAttributeXY()
              start = end
              end += 1
              (val9.segment_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v336.segment_attribute_xy.append(val9)
            start = end
            end += 1
            (_v334.disabled_exists,) = _get_struct_B().unpack(str[start:end])
            _v334.disabled_exists = bool(_v334.disabled_exists)
            _v337 = _v334.enabled
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v337.segment_attribute_xy = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.SegmentAttributeXY()
              start = end
              end += 1
              (val9.segment_attribute_xy,) = _get_struct_B().unpack(str[start:end])
              _v337.segment_attribute_xy.append(val9)
            start = end
            end += 1
            (_v334.enabled_exists,) = _get_struct_B().unpack(str[start:end])
            _v334.enabled_exists = bool(_v334.enabled_exists)
            _v338 = _v334.data
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v338.lane_attribute_list = []
            for i in range(0, length):
              val9 = j2735_msgs.msg.LaneDataAttribute()
              _x = val9
              start = end
              end += 8
              (_x.choice, _x.path_end_point_angle, _x.lane_crown_point_center, _x.lane_crown_point_right, _x.lane_crown_point_left, _x.lane_angle,) = _get_struct_Bh3bh().unpack(str[start:end])
              _v339 = val9.speed_limits
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              _v339.speed_limits = []
              for i in range(0, length):
                val11 = j2735_msgs.msg.RegulatorySpeedLimit()
                _v340 = val11.type
                start = end
                end += 1
                (_v340.speed_limit_type,) = _get_struct_B().unpack(str[start:end])
                start = end
                end += 8
                (val11.speed,) = _get_struct_d().unpack(str[start:end])
                _v339.speed_limits.append(val11)
              _v338.lane_attribute_list.append(val9)
            _x = _v334
            start = end
            end += 11
            (_x.data_exists, _x.dWitdh, _x.dWitdh_exists, _x.dElevation, _x.dElevation_exists,) = _get_struct_BfBfB().unpack(str[start:end])
            _v334.data_exists = bool(_v334.data_exists)
            _v334.dWitdh_exists = bool(_v334.dWitdh_exists)
            _v334.dElevation_exists = bool(_v334.dElevation_exists)
            start = end
            end += 1
            (val6.attributes_exists,) = _get_struct_B().unpack(str[start:end])
            val6.attributes_exists = bool(val6.attributes_exists)
            _v325.node_set_xy.append(val6)
          _v341 = _v324.computed
          start = end
          end += 2
          (_v341.reference_lane_id,) = _get_struct_H().unpack(str[start:end])
          _v342 = _v341.offset_x_axis
          _x = _v342
          start = end
          end += 5
          (_x.choice, _x.small, _x.large,) = _get_struct_B2h().unpack(str[start:end])
          _v343 = _v341.offset_y_axis
          _x = _v343
          start = end
          end += 5
          (_x.choice, _x.small, _x.large,) = _get_struct_B2h().unpack(str[start:end])
          _x = _v341
          start = end
          end += 9
          (_x.rotateXY, _x.rotatexy_exists, _x.scale_x_axis, _x.scale_x_axis_exists, _x.scale_y_axis, _x.scale_y_axis_exists,) = _get_struct_HBhBhB().unpack(str[start:end])
          _v341.rotatexy_exists = bool(_v341.rotatexy_exists)
          _v341.scale_x_axis_exists = bool(_v341.scale_x_axis_exists)
          _v341.scale_y_axis_exists = bool(_v341.scale_y_axis_exists)
          _v344 = val3.connects_to
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v344.connect_to_list = []
          for i in range(0, length):
            val5 = j2735_msgs.msg.Connection()
            _v345 = val5.connecting_lane
            start = end
            end += 2
            (_v345.lane,) = _get_struct_H().unpack(str[start:end])
            _v346 = _v345.maneuver
            start = end
            end += 2
            (_v346.allowed_maneuvers,) = _get_struct_H().unpack(str[start:end])
            start = end
            end += 1
            (_v345.maneuver_exists,) = _get_struct_B().unpack(str[start:end])
            _v345.maneuver_exists = bool(_v345.maneuver_exists)
            _v347 = val5.remote_intersection
            _x = _v347
            start = end
            end += 5
            (_x.region, _x.region_exists, _x.id,) = _get_struct_HBH().unpack(str[start:end])
            _v347.region_exists = bool(_v347.region_exists)
            _x = val5
            start = end
            end += 7
            (_x.remote_intersection_exists, _x.signal_group, _x.signal_group_exists, _x.user_class, _x.user_class_exists, _x.connection_id, _x.connection_id_exists,) = _get_struct_7B().unpack(str[start:end])
            val5.remote_intersection_exists = bool(val5.remote_intersection_exists)
            val5.signal_group_exists = bool(val5.signal_group_exists)
            val5.user_class_exists = bool(val5.user_class_exists)
            val5.connection_id_exists = bool(val5.connection_id_exists)
            _v344.connect_to_list.append(val5)
          start = end
          end += 1
          (val3.connects_to_exists,) = _get_struct_B().unpack(str[start:end])
          val3.connects_to_exists = bool(val3.connects_to_exists)
          _v348 = val3.overlay_lane_list
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sH'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v348.overlay_lane_list = numpy.frombuffer(str[start:end], dtype=numpy.uint16, count=length)
          start = end
          end += 1
          (val3.overlay_lane_list_exists,) = _get_struct_B().unpack(str[start:end])
          val3.overlay_lane_list_exists = bool(val3.overlay_lane_list_exists)
          _v310.road_lane_set_list.append(val3)
        self.road_segments.road_segment_list.append(val1)
      start = end
      end += 1
      (self.road_segments_exists,) = _get_struct_B().unpack(str[start:end])
      self.road_segments_exists = bool(self.road_segments_exists)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.data_parameters.process_method = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.data_parameters.process_method = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.data_parameters.process_agency = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.data_parameters.process_agency = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.data_parameters.last_checked_date = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.data_parameters.last_checked_date = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.data_parameters.geoid_used = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.data_parameters.geoid_used = str[start:end]
      start = end
      end += 1
      (self.data_parameters_exists,) = _get_struct_B().unpack(str[start:end])
      self.data_parameters_exists = bool(self.data_parameters_exists)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.restriction_list.restriction_class_list = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.RestrictionClassAssignment()
        start = end
        end += 1
        (val1.id,) = _get_struct_B().unpack(str[start:end])
        self.restriction_list.restriction_class_list.append(val1)
      start = end
      end += 1
      (self.restriction_list_exists,) = _get_struct_B().unpack(str[start:end])
      self.restriction_list_exists = bool(self.restriction_list_exists)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2dfB = None
def _get_struct_2dfB():
    global _struct_2dfB
    if _struct_2dfB is None:
        _struct_2dfB = struct.Struct("<2dfB")
    return _struct_2dfB
_struct_2f = None
def _get_struct_2f():
    global _struct_2f
    if _struct_2f is None:
        _struct_2f = struct.Struct("<2f")
    return _struct_2f
_struct_2i = None
def _get_struct_2i():
    global _struct_2i
    if _struct_2i is None:
        _struct_2i = struct.Struct("<2i")
    return _struct_2i
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_5B = None
def _get_struct_5B():
    global _struct_5B
    if _struct_5B is None:
        _struct_5B = struct.Struct("<5B")
    return _struct_5B
_struct_7B = None
def _get_struct_7B():
    global _struct_7B
    if _struct_7B is None:
        _struct_7B = struct.Struct("<7B")
    return _struct_7B
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_B2h = None
def _get_struct_B2h():
    global _struct_B2h
    if _struct_B2h is None:
        _struct_B2h = struct.Struct("<B2h")
    return _struct_B2h
_struct_BfBfB = None
def _get_struct_BfBfB():
    global _struct_BfBfB
    if _struct_BfBfB is None:
        _struct_BfBfB = struct.Struct("<BfBfB")
    return _struct_BfBfB
_struct_Bh3bh = None
def _get_struct_Bh3bh():
    global _struct_Bh3bh
    if _struct_Bh3bh is None:
        _struct_Bh3bh = struct.Struct("<Bh3bh")
    return _struct_Bh3bh
_struct_H = None
def _get_struct_H():
    global _struct_H
    if _struct_H is None:
        _struct_H = struct.Struct("<H")
    return _struct_H
_struct_HB = None
def _get_struct_HB():
    global _struct_HB
    if _struct_HB is None:
        _struct_HB = struct.Struct("<HB")
    return _struct_HB
_struct_HBH = None
def _get_struct_HBH():
    global _struct_HBH
    if _struct_HBH is None:
        _struct_HBH = struct.Struct("<HBH")
    return _struct_HBH
_struct_HBHB = None
def _get_struct_HBHB():
    global _struct_HBHB
    if _struct_HBHB is None:
        _struct_HBHB = struct.Struct("<HBHB")
    return _struct_HBHB
_struct_HBhBhB = None
def _get_struct_HBhBhB():
    global _struct_HBhBhB
    if _struct_HBhBhB is None:
        _struct_HBhBhB = struct.Struct("<HBhBhB")
    return _struct_HBhBhB
_struct_I5B = None
def _get_struct_I5B():
    global _struct_I5B
    if _struct_I5B is None:
        _struct_I5B = struct.Struct("<I5B")
    return _struct_I5B
_struct_d = None
def _get_struct_d():
    global _struct_d
    if _struct_d is None:
        _struct_d = struct.Struct("<d")
    return _struct_d
