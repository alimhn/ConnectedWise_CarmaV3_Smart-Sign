# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from j2735_msgs/MovementEventList.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import j2735_msgs.msg

class MovementEventList(genpy.Message):
  _md5sum = "0cee8d138e003076d7ee729f2f72a499"
  _type = "j2735_msgs/MovementEventList"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """#
# MovementEventList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The MovementEventList data frame consists of a list of MovementEvent entries.
#
# MovementEventList ::= SEQUENCE (SIZE(1..16)) OF MovementEvent
#

j2735_msgs/MovementEvent[] movement_event_list

================================================================================
MSG: j2735_msgs/MovementEvent
#
# MovementEvent.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The MovementEvent data frame contains details about a single movement. It is used by the movement state to
# convey one of number of movements (typically occurring over a sequence of times) for a SignalGroupID.
#
# MovementEvent ::= SEQUENCE {
# eventState MovementPhaseState,
# -- Consisting of:
# -- Phase state (the basic 11 states)
# -- Directional, protected, or permissive state
# timing TimeChangeDetails OPTIONAL,
# -- Timing Data in UTC time stamps for event
# -- includes start and min/max end times of phase
# -- confidence and estimated next occurrence
# speeds AdvisorySpeedList OPTIONAL,
# -- various speed advisories for use by
# -- general and specific types of vehicles
# -- supporting green-wave and other flow needs
# -- See Section 11 for converting and translating
# -- speed expressed in mph into units of m/s
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-MovementEvent}} OPTIONAL,
# ...
# }

j2735_msgs/MovementPhaseState event_state

j2735_msgs/TimeChangeDetails timing
bool timing_exists

j2735_msgs/AdvisorySpeedList speeds
bool speeds_exists

#regional #TODO: RegionalExtensions are not yet implemented in asn1c



================================================================================
MSG: j2735_msgs/MovementPhaseState
#
# MovementEvent.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DE_MovementPhaseState data element provides the overall current state of the movement (in many cases a
# signal state), including its core phase state and an indication of whether this state is permissive or protected.
#
# MovementPhaseState ::= ENUMERATED {
# -- Note that based on the regions and the operating mode not every
# -- phase will be used in all transportation modes and that not
# -- every phase will be used in all transportation modes
# unavailable (0),
# -- This state is used for unknown or error
# dark (1),
# -- The signal head is dark (unlit)
# -- Reds
# stop-Then-Proceed (2),
# -- Often called 'flashing red' in US
# -- Driver Action:
# -Stop vehicle at stop line.
# -Do not proceed unless it is safe.
# -- Note that the right to proceed either right or left
# -- it is safe may be contained in the lane description
# -- handle what is called a 'right on red'
# stop-And-Remain (3),
# -- e.g. called 'red light' in US
# -- Driver Action:
# -Stop vehicle at stop line.
# -Do not proceed.
# -- Note that the right to proceed either right or left
# -- it is safe may be contained in the lane description
# -- handle what is called a 'right on red'
# -- Greens
# pre-Movement (4),
# -- Not used in the US, red+yellow partly in EU
# -- Driver Action:
# -Stop vehicle.
# -Prepare to proceed (pending green)
# -(Prepare for transition to green/go)
# permissive-Movement-Allowed (5),
# -- Often called 'permissive green' in US
# -- Driver Action:
# -Proceed with caution,
# -must yield to all conflicting traffic
# -- Conflicting traffic may be present
# -- in the intersection conflict area
# protected-Movement-Allowed (6),
# -- Often called 'protected green' in US
# -- Driver Action:
# -Proceed, tossing caution to the wind,
# -in indicated (allowed) direction.
# -- Yellows / Ambers
# -- The vehicle is not allowed to cross the stop bar if it is possible
# -- to stop without danger.
# permissive-clearance (7),
# -- Often called 'permissive yellow' in US
# -- Driver Action:
# -Prepare to stop.
# -Proceed if unable to stop,
# -Clear Intersection.
# -- Conflicting traffic may be present
# -- in the intersection conflict area
# protected-clearance (8),
# -- Often called 'protected yellow' in US
# -- Driver Action:
# -Prepare to stop.
# -Proceed if unable to stop,
# -in indicated direction (to connected lane)
# -Clear Intersection.
# caution-Conflicting-Traffic (9)
# -- Often called 'flashing yellow' in US
# -- Often used for extended periods of time
# -- Driver Action:
# -Proceed with caution,
# -- Conflicting traffic may be present
# -- in the intersection conflict area
# }
# -- The above number assignments are not used with UPER encoding
# -- and are only to be used with DER or implicit encoding

uint8 movement_phase_state

uint8 UNAVAILABLE=0
uint8 DARK=1
uint8 STOP_THEN_PROCEED=2
uint8 STOP_AND_REMAIN=3
uint8 PRE_MOVEMENT=4
uint8 PERMISSIVE_MOVEMENT_ALLOWED=5
uint8 PROTECTED_MOVEMENT_ALLOWED=6
uint8 PERMISSIVE_CLEARANCE=7
uint8 PROTECTED_CLEARANCE=8
uint8 CAUTION_CONFLICTING_TRAFFIC=9


================================================================================
MSG: j2735_msgs/TimeChangeDetails
#
# TimeChangeDetails.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_TimeChangeDetails data frame conveys details about the timing of a phase within a movement. The core
# data concept expressed is the time stamp (time mark) at which the related phase will change to the next state. This is
# often found in the MinEndTime element, but the other elements may be needed to convey the full concept when adaptive
# timing is employed.
#
#
# TimeChangeDetails ::= SEQUENCE {
# startTime TimeMark OPTIONAL,
# -- When this phase 1st started
# minEndTime TimeMark,
# -- Expected shortest end time
# maxEndTime TimeMark OPTIONAL,
# -- Expected longest end time
# likelyTime TimeMark OPTIONAL,
# -- Best predicted value based on other data
# confidence TimeIntervalConfidence OPTIONAL,
# -- Applies to above time element only
# nextTime TimeMark OPTIONAL
# -- A rough estimate of time when
# -- this phase may next occur again
# -- used to support various ECO driving power
# -- management needs.
# }

# TimeMark ::= INTEGER (0..36001)
# -- Tenths of a second in the current or next hour
# -- In units of 1/10th second from UTC time
# -- A range of 0~36000 covers one hour
# -- The values 35991..35999 are used when a leap second occurs
# -- The value 36000 is used to indicate time >3600 seconds
# -- 36001 is to be used when value undefined or unknown
# -- Note that this is NOT expressed in GPS time
# -- or in local time
uint16 start_time
bool start_time_exists

uint16 min_end_time

uint16 max_end_time
bool max_end_time_exists

uint16 likely_time
bool likely_time_exists

#TimeIntervalConfidence ::= INTEGER (0..15)
uint8 confidence
bool confidence_exists

# TimeMark ::= INTEGER (0..36001)
uint16 next_time
bool next_time_exists


================================================================================
MSG: j2735_msgs/AdvisorySpeedList
#
# AdvisorySpeedList.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The AdvisorySpeedList data frame consists of a list of AdvisorySpeed entries.
#
# AdvisorySpeedList ::= SEQUENCE (SIZE(1..16)) OF AdvisorySpeed

j2735_msgs/AdvisorySpeed[] advisory_speed_list
================================================================================
MSG: j2735_msgs/AdvisorySpeed
#
# AdvisorySpeed.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DF_AdvisorySpeed data frame is used to convey a recommended traveling approach speed to an intersection
# from the message issuer to various travelers and vehicle types. Besides support for various eco-driving applications, this
# allows transmitting recommended speeds for specialty vehicles such as transit buses.
# AdvisorySpeed ::= SEQUENCE {
# type AdvisorySpeedType,
# -- the type of advisory which this is.
# speed SpeedAdvice OPTIONAL,
# -- See Section 11 for converting and translating speed
# -- expressed in mph into units of m/s
# -- This element is optional ONLY when superceded
# -- by the presence of a regional speed element found in
# -- Reg-AdvisorySpeed entry
# confidence SpeedConfidence OPTIONAL,
# -- A confidence value for the above speed
# distance ZoneLength OPTIONAL,
# -- Unit = 1 meter,
# -- The distance indicates the region for which the advised speed
# -- is recommended, it is specified upstream from the stop bar
# -- along the connected egressing lane
# class RestrictionClassID OPTIONAL,
# -- the vehicle types to which it applies
# -- when absent, the AdvisorySpeed applies to
# -- all motor vehicle types
# regional SEQUENCE (SIZE(1..4)) OF RegionalExtension {{REGION.Reg-AdvisorySpeed}} OPTIONAL,
# ...
# }

j2735_msgs/AdvisorySpeedType type

# SpeedAdvice ::= INTEGER (0..500) OPTIONAL
# This data element represents the recommended velocity of an object, typically a vehicle speed along a roadway,
# expressed in unsigned units of 0.1 meters per second.
#-- LSB units are 0.1 m/s^2
#-- the value 499 shall be used for values at or greater than 49.9 m/s
#-- the value 500 shall be used to indicate that speed is unavailable
float32 speed
float32 SPEED_UNAVAILABLE = 500
bool speed_exists

# SpeedConfidence is an enum already with 0 as unavailable.
j2735_msgs/SpeedConfidence confidence

# ZoneLength ::= INTEGER (0..10000)
# -- Unit = 1 meter, 0 = unknown,
# -- The value 10000 to be used for Distances >=10000 m
# -- (e.g. from known point to another point along a
# -- known path, often against traffic flow direction
# -- when used for measuring queues)
uint16 distance
uint16 DISTANCE_UNKNOWN=0
bool distance_exists

# RestrictionClassID ::= INTEGER (0..255)
uint8 restriction_class_id
bool restriction_class_id_exists

# regional #TODO: RegionalExtensions are not yet implemented in asn1c



================================================================================
MSG: j2735_msgs/AdvisorySpeedType
#
# AdvisorySpeedType.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DE_AdvisorySpeedType data element relates the type of travel to which a given speed refers. This element is
# typically used as part of an AdvisorySpeed data frame for signal phase and timing data.
#
# AdvisorySpeedType ::= ENUMERATED {
# none (0),
# greenwave (1),
# ecoDrive (2),
# transit (3),
# ...
# } -- Note: subject to further growth

uint8 advisory_speed_type

uint8 NONE=0
uint8 GREENWAVE=1
uint8 ECODRIVE=2
uint8 TRANSIT=3

================================================================================
MSG: j2735_msgs/SpeedConfidence
#
# SpeedConfidence.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The DE_SpeedConfidence data element is used to provide the 95% confidence level for the currently reported
# value of DE_Speed, taking into account the current calibration and precision of the sensor(s) used to measure and/or
# calculate the value.

# SpeedConfidence ::= ENUMERATED {
# unavailable (0), -- Not Equipped or unavailable
# prec100ms (1), -- 100 meters / sec
# prec10ms(2), -- 10 meters / sec
# prec5ms (3), -- 5 meters / sec
# prec1ms (4), -- 1 meters / sec
# prec0-1ms (5), -- 0.1 meters / sec
# prec0-05ms (6), -- -- 0.05 meters / sec
# prec0-01ms (7) -- -- 0.01 meters / sec
# }

uint8 speed_confidence

uint8 UNAVAILABLE=0
uint8 PREC100MS=1
uint8 PREC10MS=2
uint8 PREC5MS=3
uint8 PREC1MS=4
uint8 PREC0_1MS=5
uint8 PREC0_05MS=6
uint8 PREC0_01MS=7"""
  __slots__ = ['movement_event_list']
  _slot_types = ['j2735_msgs/MovementEvent[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       movement_event_list

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(MovementEventList, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.movement_event_list is None:
        self.movement_event_list = []
    else:
      self.movement_event_list = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.movement_event_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.movement_event_list:
        _v1 = val1.event_state
        _x = _v1.movement_phase_state
        buff.write(_get_struct_B().pack(_x))
        _v2 = val1.timing
        _x = _v2
        buff.write(_get_struct_HB2HBH3BHB().pack(_x.start_time, _x.start_time_exists, _x.min_end_time, _x.max_end_time, _x.max_end_time_exists, _x.likely_time, _x.likely_time_exists, _x.confidence, _x.confidence_exists, _x.next_time, _x.next_time_exists))
        _x = val1.timing_exists
        buff.write(_get_struct_B().pack(_x))
        _v3 = val1.speeds
        length = len(_v3.advisory_speed_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v3.advisory_speed_list:
          _v4 = val3.type
          _x = _v4.advisory_speed_type
          buff.write(_get_struct_B().pack(_x))
          _x = val3
          buff.write(_get_struct_fB().pack(_x.speed, _x.speed_exists))
          _v5 = val3.confidence
          _x = _v5.speed_confidence
          buff.write(_get_struct_B().pack(_x))
          _x = val3
          buff.write(_get_struct_H3B().pack(_x.distance, _x.distance_exists, _x.restriction_class_id, _x.restriction_class_id_exists))
        _x = val1.speeds_exists
        buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.movement_event_list is None:
        self.movement_event_list = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.movement_event_list = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.MovementEvent()
        _v6 = val1.event_state
        start = end
        end += 1
        (_v6.movement_phase_state,) = _get_struct_B().unpack(str[start:end])
        _v7 = val1.timing
        _x = _v7
        start = end
        end += 16
        (_x.start_time, _x.start_time_exists, _x.min_end_time, _x.max_end_time, _x.max_end_time_exists, _x.likely_time, _x.likely_time_exists, _x.confidence, _x.confidence_exists, _x.next_time, _x.next_time_exists,) = _get_struct_HB2HBH3BHB().unpack(str[start:end])
        _v7.start_time_exists = bool(_v7.start_time_exists)
        _v7.max_end_time_exists = bool(_v7.max_end_time_exists)
        _v7.likely_time_exists = bool(_v7.likely_time_exists)
        _v7.confidence_exists = bool(_v7.confidence_exists)
        _v7.next_time_exists = bool(_v7.next_time_exists)
        start = end
        end += 1
        (val1.timing_exists,) = _get_struct_B().unpack(str[start:end])
        val1.timing_exists = bool(val1.timing_exists)
        _v8 = val1.speeds
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v8.advisory_speed_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.AdvisorySpeed()
          _v9 = val3.type
          start = end
          end += 1
          (_v9.advisory_speed_type,) = _get_struct_B().unpack(str[start:end])
          _x = val3
          start = end
          end += 5
          (_x.speed, _x.speed_exists,) = _get_struct_fB().unpack(str[start:end])
          val3.speed_exists = bool(val3.speed_exists)
          _v10 = val3.confidence
          start = end
          end += 1
          (_v10.speed_confidence,) = _get_struct_B().unpack(str[start:end])
          _x = val3
          start = end
          end += 5
          (_x.distance, _x.distance_exists, _x.restriction_class_id, _x.restriction_class_id_exists,) = _get_struct_H3B().unpack(str[start:end])
          val3.distance_exists = bool(val3.distance_exists)
          val3.restriction_class_id_exists = bool(val3.restriction_class_id_exists)
          _v8.advisory_speed_list.append(val3)
        start = end
        end += 1
        (val1.speeds_exists,) = _get_struct_B().unpack(str[start:end])
        val1.speeds_exists = bool(val1.speeds_exists)
        self.movement_event_list.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.movement_event_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.movement_event_list:
        _v11 = val1.event_state
        _x = _v11.movement_phase_state
        buff.write(_get_struct_B().pack(_x))
        _v12 = val1.timing
        _x = _v12
        buff.write(_get_struct_HB2HBH3BHB().pack(_x.start_time, _x.start_time_exists, _x.min_end_time, _x.max_end_time, _x.max_end_time_exists, _x.likely_time, _x.likely_time_exists, _x.confidence, _x.confidence_exists, _x.next_time, _x.next_time_exists))
        _x = val1.timing_exists
        buff.write(_get_struct_B().pack(_x))
        _v13 = val1.speeds
        length = len(_v13.advisory_speed_list)
        buff.write(_struct_I.pack(length))
        for val3 in _v13.advisory_speed_list:
          _v14 = val3.type
          _x = _v14.advisory_speed_type
          buff.write(_get_struct_B().pack(_x))
          _x = val3
          buff.write(_get_struct_fB().pack(_x.speed, _x.speed_exists))
          _v15 = val3.confidence
          _x = _v15.speed_confidence
          buff.write(_get_struct_B().pack(_x))
          _x = val3
          buff.write(_get_struct_H3B().pack(_x.distance, _x.distance_exists, _x.restriction_class_id, _x.restriction_class_id_exists))
        _x = val1.speeds_exists
        buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.movement_event_list is None:
        self.movement_event_list = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.movement_event_list = []
      for i in range(0, length):
        val1 = j2735_msgs.msg.MovementEvent()
        _v16 = val1.event_state
        start = end
        end += 1
        (_v16.movement_phase_state,) = _get_struct_B().unpack(str[start:end])
        _v17 = val1.timing
        _x = _v17
        start = end
        end += 16
        (_x.start_time, _x.start_time_exists, _x.min_end_time, _x.max_end_time, _x.max_end_time_exists, _x.likely_time, _x.likely_time_exists, _x.confidence, _x.confidence_exists, _x.next_time, _x.next_time_exists,) = _get_struct_HB2HBH3BHB().unpack(str[start:end])
        _v17.start_time_exists = bool(_v17.start_time_exists)
        _v17.max_end_time_exists = bool(_v17.max_end_time_exists)
        _v17.likely_time_exists = bool(_v17.likely_time_exists)
        _v17.confidence_exists = bool(_v17.confidence_exists)
        _v17.next_time_exists = bool(_v17.next_time_exists)
        start = end
        end += 1
        (val1.timing_exists,) = _get_struct_B().unpack(str[start:end])
        val1.timing_exists = bool(val1.timing_exists)
        _v18 = val1.speeds
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v18.advisory_speed_list = []
        for i in range(0, length):
          val3 = j2735_msgs.msg.AdvisorySpeed()
          _v19 = val3.type
          start = end
          end += 1
          (_v19.advisory_speed_type,) = _get_struct_B().unpack(str[start:end])
          _x = val3
          start = end
          end += 5
          (_x.speed, _x.speed_exists,) = _get_struct_fB().unpack(str[start:end])
          val3.speed_exists = bool(val3.speed_exists)
          _v20 = val3.confidence
          start = end
          end += 1
          (_v20.speed_confidence,) = _get_struct_B().unpack(str[start:end])
          _x = val3
          start = end
          end += 5
          (_x.distance, _x.distance_exists, _x.restriction_class_id, _x.restriction_class_id_exists,) = _get_struct_H3B().unpack(str[start:end])
          val3.distance_exists = bool(val3.distance_exists)
          val3.restriction_class_id_exists = bool(val3.restriction_class_id_exists)
          _v18.advisory_speed_list.append(val3)
        start = end
        end += 1
        (val1.speeds_exists,) = _get_struct_B().unpack(str[start:end])
        val1.speeds_exists = bool(val1.speeds_exists)
        self.movement_event_list.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_H3B = None
def _get_struct_H3B():
    global _struct_H3B
    if _struct_H3B is None:
        _struct_H3B = struct.Struct("<H3B")
    return _struct_H3B
_struct_HB2HBH3BHB = None
def _get_struct_HB2HBH3BHB():
    global _struct_HB2HBH3BHB
    if _struct_HB2HBH3BHB is None:
        _struct_HB2HBH3BHB = struct.Struct("<HB2HBH3BHB")
    return _struct_HB2HBH3BHB
_struct_fB = None
def _get_struct_fB():
    global _struct_fB
    if _struct_fB is None:
        _struct_fB = struct.Struct("<fB")
    return _struct_fB
