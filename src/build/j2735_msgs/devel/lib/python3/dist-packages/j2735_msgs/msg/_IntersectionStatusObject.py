# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from j2735_msgs/IntersectionStatusObject.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class IntersectionStatusObject(genpy.Message):
  _md5sum = "189e3f94ed4f7d42fc526476bb41da86"
  _type = "j2735_msgs/IntersectionStatusObject"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """#
# IntersectionStatusObject.msg
#
# J2735 2016 message format.
#
# @author Mae Fromm
# @version 0.1
#
# The Intersection Status Object contains Advanced Traffic Controller (ATC) status information that may be sent to
# local OBUs as part of the SPAT process.

# IntersectionStatusObject ::= BIT STRING {
# manualControlIsEnabled (0),
# -- Timing reported is per programmed values, etc. but person
# -- at cabinet can manually request that certain intervals are
# -- terminated early (e.g. green).
# stopTimeIsActivated (1),
# -- And all counting/timing has stopped.
# failureFlash (2),
# -- Above to be used for any detected hardware failures,
# -- e.g. conflict monitor as well as for police flash
# preemptIsActive (3),
# signalPriorityIsActive (4),
# -- Additional states
# fixedTimeOperation (5),
# -- Schedule of signals is based on time only
# -- (i.e. the state can be calculated)
# trafficDependentOperation (6),
# -- Operation is based on different levels of traffic parameters
# -- (requests, duration of gaps or more complex parameters)
# standbyOperation (7),
# -- Controller: partially switched off or partially amber flashing
# failureMode (8),
# -- Controller has a problem or failure in operation
# off (9),
# -- Controller is switched off
# -- Related to MAP and SPAT bindings
# recentMAPmessageUpdate (10),
# -- Map revision with content changes
# recentChangeInMAPassignedLanesIDsUsed (11),
# -- Change in MAP's assigned lanes used (lane changes)
# -- Changes in the active lane list description
# noValidMAPisAvailableAtThisTime (12),
# -- MAP (and various lanes indexes) not available
# noValidSPATisAvailableAtThisTime (13)
# -- SPAT system is not working at this time
# -- Bits 14,15 reserved at this time and shall be zero
# } (SIZE(16))

uint16 intersection_status_object"""
  __slots__ = ['intersection_status_object']
  _slot_types = ['uint16']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       intersection_status_object

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(IntersectionStatusObject, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.intersection_status_object is None:
        self.intersection_status_object = 0
    else:
      self.intersection_status_object = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.intersection_status_object
      buff.write(_get_struct_H().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 2
      (self.intersection_status_object,) = _get_struct_H().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.intersection_status_object
      buff.write(_get_struct_H().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 2
      (self.intersection_status_object,) = _get_struct_H().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_H = None
def _get_struct_H():
    global _struct_H
    if _struct_H is None:
        _struct_H = struct.Struct("<H")
    return _struct_H
