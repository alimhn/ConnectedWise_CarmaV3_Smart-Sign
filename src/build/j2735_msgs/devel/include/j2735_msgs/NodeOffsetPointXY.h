// Generated by gencpp from file j2735_msgs/NodeOffsetPointXY.msg
// DO NOT EDIT!


#ifndef J2735_MSGS_MESSAGE_NODEOFFSETPOINTXY_H
#define J2735_MSGS_MESSAGE_NODEOFFSETPOINTXY_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <j2735_msgs/NodeXY20b.h>
#include <j2735_msgs/NodeXY22b.h>
#include <j2735_msgs/NodeXY24b.h>
#include <j2735_msgs/NodeXY26b.h>
#include <j2735_msgs/NodeXY28b.h>
#include <j2735_msgs/NodeXY32b.h>
#include <j2735_msgs/NodeLLmD64b.h>

namespace j2735_msgs
{
template <class ContainerAllocator>
struct NodeOffsetPointXY_
{
  typedef NodeOffsetPointXY_<ContainerAllocator> Type;

  NodeOffsetPointXY_()
    : choice(0)
    , node_xy1()
    , node_xy2()
    , node_xy3()
    , node_xy4()
    , node_xy5()
    , node_xy6()
    , node_latlon()  {
    }
  NodeOffsetPointXY_(const ContainerAllocator& _alloc)
    : choice(0)
    , node_xy1(_alloc)
    , node_xy2(_alloc)
    , node_xy3(_alloc)
    , node_xy4(_alloc)
    , node_xy5(_alloc)
    , node_xy6(_alloc)
    , node_latlon(_alloc)  {
  (void)_alloc;
    }



   typedef uint8_t _choice_type;
  _choice_type choice;

   typedef  ::j2735_msgs::NodeXY20b_<ContainerAllocator>  _node_xy1_type;
  _node_xy1_type node_xy1;

   typedef  ::j2735_msgs::NodeXY22b_<ContainerAllocator>  _node_xy2_type;
  _node_xy2_type node_xy2;

   typedef  ::j2735_msgs::NodeXY24b_<ContainerAllocator>  _node_xy3_type;
  _node_xy3_type node_xy3;

   typedef  ::j2735_msgs::NodeXY26b_<ContainerAllocator>  _node_xy4_type;
  _node_xy4_type node_xy4;

   typedef  ::j2735_msgs::NodeXY28b_<ContainerAllocator>  _node_xy5_type;
  _node_xy5_type node_xy5;

   typedef  ::j2735_msgs::NodeXY32b_<ContainerAllocator>  _node_xy6_type;
  _node_xy6_type node_xy6;

   typedef  ::j2735_msgs::NodeLLmD64b_<ContainerAllocator>  _node_latlon_type;
  _node_latlon_type node_latlon;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(NODE_XY1)
  #undef NODE_XY1
#endif
#if defined(_WIN32) && defined(NODE_XY2)
  #undef NODE_XY2
#endif
#if defined(_WIN32) && defined(NODE_XY3)
  #undef NODE_XY3
#endif
#if defined(_WIN32) && defined(NODE_XY4)
  #undef NODE_XY4
#endif
#if defined(_WIN32) && defined(NODE_XY5)
  #undef NODE_XY5
#endif
#if defined(_WIN32) && defined(NODE_XY6)
  #undef NODE_XY6
#endif
#if defined(_WIN32) && defined(NODE_LATLON)
  #undef NODE_LATLON
#endif

  enum {
    NODE_XY1 = 0u,
    NODE_XY2 = 1u,
    NODE_XY3 = 2u,
    NODE_XY4 = 3u,
    NODE_XY5 = 4u,
    NODE_XY6 = 5u,
    NODE_LATLON = 6u,
  };


  typedef boost::shared_ptr< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> const> ConstPtr;

}; // struct NodeOffsetPointXY_

typedef ::j2735_msgs::NodeOffsetPointXY_<std::allocator<void> > NodeOffsetPointXY;

typedef boost::shared_ptr< ::j2735_msgs::NodeOffsetPointXY > NodeOffsetPointXYPtr;
typedef boost::shared_ptr< ::j2735_msgs::NodeOffsetPointXY const> NodeOffsetPointXYConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator1> & lhs, const ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator2> & rhs)
{
  return lhs.choice == rhs.choice &&
    lhs.node_xy1 == rhs.node_xy1 &&
    lhs.node_xy2 == rhs.node_xy2 &&
    lhs.node_xy3 == rhs.node_xy3 &&
    lhs.node_xy4 == rhs.node_xy4 &&
    lhs.node_xy5 == rhs.node_xy5 &&
    lhs.node_xy6 == rhs.node_xy6 &&
    lhs.node_latlon == rhs.node_latlon;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator1> & lhs, const ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace j2735_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ec16b09fe0e361cc7f02f06980d20de3";
  }

  static const char* value(const ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xec16b09fe0e361ccULL;
  static const uint64_t static_value2 = 0x7f02f06980d20de3ULL;
};

template<class ContainerAllocator>
struct DataType< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> >
{
  static const char* value()
  {
    return "j2735_msgs/NodeOffsetPointXY";
  }

  static const char* value(const ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#\n"
"# NodeOffsetPointXY.msg\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# @author Mae Fromm\n"
"# @version 0.1\n"
"#\n"
"# The DF_NodeOffsetPointXY data frame presents a structure to hold different sized data frames for a single node\n"
"# point in a lane. Nodes are described in terms of X and Y offsets in units of 1 centimeter (when zoom is 1:1).\n"
"#\n"
"# NodeOffsetPointXY ::= CHOICE {\n"
"# -- Nodes with X,Y content\n"
"# node-XY1 Node-XY-20b, -- node is within 5.11m of last node\n"
"# node-XY2 Node-XY-22b, -- node is within 10.23m of last node\n"
"# node-XY3 Node-XY-24b, -- node is within 20.47m of last node\n"
"# node-XY4 Node-XY-26b, -- node is within 40.96m of last node\n"
"# node-XY5 Node-XY-28b, -- node is within 81.91m of last node\n"
"# node-XY6 Node-XY-32b, -- node is within 327.67m of last node\n"
"# node-LatLon Node-LLmD-64b, -- node is a full 32b Lat/Lon range\n"
"# regional RegionalExtension {{REGION.Reg-NodeOffsetPointXY}}\n"
"# 	-- node which follows is of a\n"
"# 	-- regional definition type\n"
"# }\n"
"#\n"
"\n"
"uint8 choice\n"
"uint8 NODE_XY1=0\n"
"uint8 NODE_XY2=1\n"
"uint8 NODE_XY3=2\n"
"uint8 NODE_XY4=3\n"
"uint8 NODE_XY5=4\n"
"uint8 NODE_XY6=5\n"
"uint8 NODE_LATLON=6\n"
"\n"
"j2735_msgs/NodeXY20b node_xy1\n"
"j2735_msgs/NodeXY22b node_xy2\n"
"j2735_msgs/NodeXY24b node_xy3\n"
"j2735_msgs/NodeXY26b node_xy4\n"
"j2735_msgs/NodeXY28b node_xy5\n"
"j2735_msgs/NodeXY32b node_xy6\n"
"j2735_msgs/NodeLLmD64b node_latlon\n"
"# regional #TODO: RegionalExtensions are not yet implemented in asn1c\n"
"================================================================================\n"
"MSG: j2735_msgs/NodeXY20b\n"
"#\n"
"# NodeXY20b.msg\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# @author Mae Fromm\n"
"# @version 0.1\n"
"#\n"
"# A 20-bit node type with offset values from the last point in X and Y.\n"
"#\n"
"# Node-XY-20b ::= SEQUENCE {\n"
"# x Offset-B10,\n"
"# y Offset-B10\n"
"# }\n"
"\n"
"# Offset-B10 ::= INTEGER (-512..511)\n"
"# -- a range of +- 5.11 meters\n"
"# A 10-bit delta offset in X, Y or Z direction from some known point. For non-vehicle centric coordinate frames of\n"
"# reference, offset is positive to the East (X) and to the North (Y) directions. The most negative value shall be used to\n"
"# indicate an unknown value.\n"
"\n"
"float32 x\n"
"float32 y\n"
"================================================================================\n"
"MSG: j2735_msgs/NodeXY22b\n"
"#\n"
"# NodeXY22b.msg\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# @author Mae Fromm\n"
"# @version 0.1\n"
"#\n"
"# A 22-bit node type with offset values from the last point in X and Y.\n"
"\n"
"# Node-XY-22b ::= SEQUENCE {\n"
"# x Offset-B11,\n"
"# y Offset-B11\n"
"# }\n"
"\n"
"# Offset-B11 ::= INTEGER (-1024..1023)\n"
"# -- a range of +- 10.23 meters\n"
"# An 11-bit delta offset in X or Y direction from some known point. For non-vehicle centric coordinate frames of\n"
"# reference, offset is positive to the East (X) and to the North (Y) directions. The most negative value shall be used to\n"
"# indicate an unknown value.\n"
"\n"
"float32 x\n"
"float32 y\n"
"================================================================================\n"
"MSG: j2735_msgs/NodeXY24b\n"
"#\n"
"# NodeXY24b.msg\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# @author Mae Fromm\n"
"# @version 0.1\n"
"#\n"
"# A 24-bit node type with offset values from the last point in X and Y.\n"
"#\n"
"# Node-XY-24b ::= SEQUENCE {\n"
"# x Offset-B12,\n"
"# y Offset-B12\n"
"# }\n"
"\n"
"\n"
"# Offset-B12 ::= INTEGER (-2048..2047)\n"
"# -- a range of +- 20.47 meters\n"
"# A 12-bit delta offset in X, Y or Z direction from some known point. For non-vehicle centric coordinate frames of\n"
"# reference, non-vehicle centric coordinate frames of reference, offset is positive to the East (X) and to the North (Y)\n"
"# directions. The most negative value shall be used to indicate an unknown value.\n"
"\n"
"float32 x\n"
"float32 y\n"
"================================================================================\n"
"MSG: j2735_msgs/NodeXY26b\n"
"#\n"
"# NodeXY26b.msg\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# @author Mae Fromm\n"
"# @version 0.1\n"
"#\n"
"# A 26-bit node type with offset values from the last point in X and Y.\n"
"\n"
"# Node-XY-26b ::= SEQUENCE {\n"
"# x Offset-B13,\n"
"# y Offset-B13\n"
"# }\n"
"\n"
"# Offset-B13 ::= INTEGER (-4096..4095)\n"
"# -- a range of +- 40.95 meters\n"
"# A 13-bit delta offset in X or Y direction from some known point. For non-vehicle centric coordinate frames of\n"
"# reference, offset is positive to the East (X) and to the North (Y) directions. The most negative value shall be used to\n"
"# indicate an unknown value.\n"
"\n"
"float32 x\n"
"float32 y\n"
"================================================================================\n"
"MSG: j2735_msgs/NodeXY28b\n"
"#\n"
"# NodeXY28b.msg\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# @author Mae Fromm\n"
"# @version 0.1\n"
"#\n"
"# A 28-bit node type with offset values from the last point in X and Y.\n"
"\n"
"# Node-XY-28b ::= SEQUENCE {\n"
"# x Offset-B14,\n"
"# y Offset-B14\n"
"# }\n"
"\n"
"# A 14-bit delta offset in X or Y direction from some known point. For non-vehicle centric coordinate frames of\n"
"# reference, offset is positive to the East (X) and to the North (Y) directions.\n"
"# Offset-B14 ::= INTEGER (-8192..8191)\n"
"# -- a range of +- 81.91 meters\n"
"\n"
"float32 x\n"
"float32 y\n"
"\n"
"================================================================================\n"
"MSG: j2735_msgs/NodeXY32b\n"
"#\n"
"# NodeXY32b.msg\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# @author Mae Fromm\n"
"# @version 0.1\n"
"#\n"
"# A 32-bit node type with offset values from the last point in X and Y.\n"
"\n"
"# Node-XY-32b ::= SEQUENCE {\n"
"# x Offset-B16,\n"
"# y Offset-B16\n"
"# }\n"
"\n"
"# A 16-bit delta offset in X, Y or Z direction from some known point. For non-vehicle centric coordinate frames of\n"
"# reference, offset is positive to the East (X) and to the North (Y) directions. The most negative value shall be used to\n"
"# indicate an unknown value.\n"
"# Offset-B16 ::= INTEGER (-32768..32767)\n"
"# -- a range of +- 327.68 meters\n"
"\n"
"float32 x\n"
"float32 y\n"
"================================================================================\n"
"MSG: j2735_msgs/NodeLLmD64b\n"
"#\n"
"# NodeLLmD64b.msg\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# @author Mae Fromm\n"
"# @version 0.1\n"
"#\n"
"# A 64-bit node type with lat-long values expressed in standard SAE one tenth of a micro degree.\n"
"\n"
"# Node-LLmD-64b ::= SEQUENCE {\n"
"# lon Longitude,\n"
"# lat Latitude\n"
"# }\n"
"\n"
"#Longitude ::= INTEGER (-1799999999..1800000001)\n"
"#  -- LSB = 1/10 micro degree\n"
"#  -- Providing a range of plus-minus 180 degrees\n"
"#  -- Convert to degree with factor 0.0000001 when field is used\n"
"int32 longitude\n"
"\n"
"int32 LONGITUDE_UNAVAILABLE = 1800000001\n"
"int32 LONGITUDE_MAX = 1800000000\n"
"int32 LONGITUDE_MIN = -1799999999\n"
"\n"
"#Latitude ::= INTEGER (-900000000..900000001)\n"
"#  -- LSB = 1/10 micro degree\n"
"#  -- Providing a range of plus-minus 90 degrees\n"
"#  -- Convert to degree with factor 0.0000001 when field is used\n"
"int32 latitude\n"
"\n"
"int32 LATITUDE_UNAVAILABLE = 900000001\n"
"int32 LATITUDE_MAX = 900000000\n"
"int32 LATITUDE_MIN = -900000000\n"
"\n"
"\n"
"\n"
"\n"
;
  }

  static const char* value(const ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.choice);
      stream.next(m.node_xy1);
      stream.next(m.node_xy2);
      stream.next(m.node_xy3);
      stream.next(m.node_xy4);
      stream.next(m.node_xy5);
      stream.next(m.node_xy6);
      stream.next(m.node_latlon);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct NodeOffsetPointXY_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::j2735_msgs::NodeOffsetPointXY_<ContainerAllocator>& v)
  {
    s << indent << "choice: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.choice);
    s << indent << "node_xy1: ";
    s << std::endl;
    Printer< ::j2735_msgs::NodeXY20b_<ContainerAllocator> >::stream(s, indent + "  ", v.node_xy1);
    s << indent << "node_xy2: ";
    s << std::endl;
    Printer< ::j2735_msgs::NodeXY22b_<ContainerAllocator> >::stream(s, indent + "  ", v.node_xy2);
    s << indent << "node_xy3: ";
    s << std::endl;
    Printer< ::j2735_msgs::NodeXY24b_<ContainerAllocator> >::stream(s, indent + "  ", v.node_xy3);
    s << indent << "node_xy4: ";
    s << std::endl;
    Printer< ::j2735_msgs::NodeXY26b_<ContainerAllocator> >::stream(s, indent + "  ", v.node_xy4);
    s << indent << "node_xy5: ";
    s << std::endl;
    Printer< ::j2735_msgs::NodeXY28b_<ContainerAllocator> >::stream(s, indent + "  ", v.node_xy5);
    s << indent << "node_xy6: ";
    s << std::endl;
    Printer< ::j2735_msgs::NodeXY32b_<ContainerAllocator> >::stream(s, indent + "  ", v.node_xy6);
    s << indent << "node_latlon: ";
    s << std::endl;
    Printer< ::j2735_msgs::NodeLLmD64b_<ContainerAllocator> >::stream(s, indent + "  ", v.node_latlon);
  }
};

} // namespace message_operations
} // namespace ros

#endif // J2735_MSGS_MESSAGE_NODEOFFSETPOINTXY_H
