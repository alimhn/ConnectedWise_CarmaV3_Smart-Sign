// Generated by gencpp from file j2735_msgs/MovementPhaseState.msg
// DO NOT EDIT!


#ifndef J2735_MSGS_MESSAGE_MOVEMENTPHASESTATE_H
#define J2735_MSGS_MESSAGE_MOVEMENTPHASESTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace j2735_msgs
{
template <class ContainerAllocator>
struct MovementPhaseState_
{
  typedef MovementPhaseState_<ContainerAllocator> Type;

  MovementPhaseState_()
    : movement_phase_state(0)  {
    }
  MovementPhaseState_(const ContainerAllocator& _alloc)
    : movement_phase_state(0)  {
  (void)_alloc;
    }



   typedef uint8_t _movement_phase_state_type;
  _movement_phase_state_type movement_phase_state;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(UNAVAILABLE)
  #undef UNAVAILABLE
#endif
#if defined(_WIN32) && defined(DARK)
  #undef DARK
#endif
#if defined(_WIN32) && defined(STOP_THEN_PROCEED)
  #undef STOP_THEN_PROCEED
#endif
#if defined(_WIN32) && defined(STOP_AND_REMAIN)
  #undef STOP_AND_REMAIN
#endif
#if defined(_WIN32) && defined(PRE_MOVEMENT)
  #undef PRE_MOVEMENT
#endif
#if defined(_WIN32) && defined(PERMISSIVE_MOVEMENT_ALLOWED)
  #undef PERMISSIVE_MOVEMENT_ALLOWED
#endif
#if defined(_WIN32) && defined(PROTECTED_MOVEMENT_ALLOWED)
  #undef PROTECTED_MOVEMENT_ALLOWED
#endif
#if defined(_WIN32) && defined(PERMISSIVE_CLEARANCE)
  #undef PERMISSIVE_CLEARANCE
#endif
#if defined(_WIN32) && defined(PROTECTED_CLEARANCE)
  #undef PROTECTED_CLEARANCE
#endif
#if defined(_WIN32) && defined(CAUTION_CONFLICTING_TRAFFIC)
  #undef CAUTION_CONFLICTING_TRAFFIC
#endif

  enum {
    UNAVAILABLE = 0u,
    DARK = 1u,
    STOP_THEN_PROCEED = 2u,
    STOP_AND_REMAIN = 3u,
    PRE_MOVEMENT = 4u,
    PERMISSIVE_MOVEMENT_ALLOWED = 5u,
    PROTECTED_MOVEMENT_ALLOWED = 6u,
    PERMISSIVE_CLEARANCE = 7u,
    PROTECTED_CLEARANCE = 8u,
    CAUTION_CONFLICTING_TRAFFIC = 9u,
  };


  typedef boost::shared_ptr< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> const> ConstPtr;

}; // struct MovementPhaseState_

typedef ::j2735_msgs::MovementPhaseState_<std::allocator<void> > MovementPhaseState;

typedef boost::shared_ptr< ::j2735_msgs::MovementPhaseState > MovementPhaseStatePtr;
typedef boost::shared_ptr< ::j2735_msgs::MovementPhaseState const> MovementPhaseStateConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::j2735_msgs::MovementPhaseState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::j2735_msgs::MovementPhaseState_<ContainerAllocator1> & lhs, const ::j2735_msgs::MovementPhaseState_<ContainerAllocator2> & rhs)
{
  return lhs.movement_phase_state == rhs.movement_phase_state;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::j2735_msgs::MovementPhaseState_<ContainerAllocator1> & lhs, const ::j2735_msgs::MovementPhaseState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace j2735_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "7d9d830cc3b901bf4f8e5aaa54a51d3d";
  }

  static const char* value(const ::j2735_msgs::MovementPhaseState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x7d9d830cc3b901bfULL;
  static const uint64_t static_value2 = 0x4f8e5aaa54a51d3dULL;
};

template<class ContainerAllocator>
struct DataType< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "j2735_msgs/MovementPhaseState";
  }

  static const char* value(const ::j2735_msgs::MovementPhaseState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#\n"
"# MovementEvent.msg\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# @author Mae Fromm\n"
"# @version 0.1\n"
"#\n"
"# The DE_MovementPhaseState data element provides the overall current state of the movement (in many cases a\n"
"# signal state), including its core phase state and an indication of whether this state is permissive or protected.\n"
"#\n"
"# MovementPhaseState ::= ENUMERATED {\n"
"# -- Note that based on the regions and the operating mode not every\n"
"# -- phase will be used in all transportation modes and that not\n"
"# -- every phase will be used in all transportation modes\n"
"# unavailable (0),\n"
"# -- This state is used for unknown or error\n"
"# dark (1),\n"
"# -- The signal head is dark (unlit)\n"
"# -- Reds\n"
"# stop-Then-Proceed (2),\n"
"# -- Often called 'flashing red' in US\n"
"# -- Driver Action:\n"
"# -Stop vehicle at stop line.\n"
"# -Do not proceed unless it is safe.\n"
"# -- Note that the right to proceed either right or left\n"
"# -- it is safe may be contained in the lane description\n"
"# -- handle what is called a 'right on red'\n"
"# stop-And-Remain (3),\n"
"# -- e.g. called 'red light' in US\n"
"# -- Driver Action:\n"
"# -Stop vehicle at stop line.\n"
"# -Do not proceed.\n"
"# -- Note that the right to proceed either right or left\n"
"# -- it is safe may be contained in the lane description\n"
"# -- handle what is called a 'right on red'\n"
"# -- Greens\n"
"# pre-Movement (4),\n"
"# -- Not used in the US, red+yellow partly in EU\n"
"# -- Driver Action:\n"
"# -Stop vehicle.\n"
"# -Prepare to proceed (pending green)\n"
"# -(Prepare for transition to green/go)\n"
"# permissive-Movement-Allowed (5),\n"
"# -- Often called 'permissive green' in US\n"
"# -- Driver Action:\n"
"# -Proceed with caution,\n"
"# -must yield to all conflicting traffic\n"
"# -- Conflicting traffic may be present\n"
"# -- in the intersection conflict area\n"
"# protected-Movement-Allowed (6),\n"
"# -- Often called 'protected green' in US\n"
"# -- Driver Action:\n"
"# -Proceed, tossing caution to the wind,\n"
"# -in indicated (allowed) direction.\n"
"# -- Yellows / Ambers\n"
"# -- The vehicle is not allowed to cross the stop bar if it is possible\n"
"# -- to stop without danger.\n"
"# permissive-clearance (7),\n"
"# -- Often called 'permissive yellow' in US\n"
"# -- Driver Action:\n"
"# -Prepare to stop.\n"
"# -Proceed if unable to stop,\n"
"# -Clear Intersection.\n"
"# -- Conflicting traffic may be present\n"
"# -- in the intersection conflict area\n"
"# protected-clearance (8),\n"
"# -- Often called 'protected yellow' in US\n"
"# -- Driver Action:\n"
"# -Prepare to stop.\n"
"# -Proceed if unable to stop,\n"
"# -in indicated direction (to connected lane)\n"
"# -Clear Intersection.\n"
"# caution-Conflicting-Traffic (9)\n"
"# -- Often called 'flashing yellow' in US\n"
"# -- Often used for extended periods of time\n"
"# -- Driver Action:\n"
"# -Proceed with caution,\n"
"# -- Conflicting traffic may be present\n"
"# -- in the intersection conflict area\n"
"# }\n"
"# -- The above number assignments are not used with UPER encoding\n"
"# -- and are only to be used with DER or implicit encoding\n"
"\n"
"uint8 movement_phase_state\n"
"\n"
"uint8 UNAVAILABLE=0\n"
"uint8 DARK=1\n"
"uint8 STOP_THEN_PROCEED=2\n"
"uint8 STOP_AND_REMAIN=3\n"
"uint8 PRE_MOVEMENT=4\n"
"uint8 PERMISSIVE_MOVEMENT_ALLOWED=5\n"
"uint8 PROTECTED_MOVEMENT_ALLOWED=6\n"
"uint8 PERMISSIVE_CLEARANCE=7\n"
"uint8 PROTECTED_CLEARANCE=8\n"
"uint8 CAUTION_CONFLICTING_TRAFFIC=9\n"
"\n"
;
  }

  static const char* value(const ::j2735_msgs::MovementPhaseState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.movement_phase_state);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct MovementPhaseState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::j2735_msgs::MovementPhaseState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::j2735_msgs::MovementPhaseState_<ContainerAllocator>& v)
  {
    s << indent << "movement_phase_state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.movement_phase_state);
  }
};

} // namespace message_operations
} // namespace ros

#endif // J2735_MSGS_MESSAGE_MOVEMENTPHASESTATE_H
