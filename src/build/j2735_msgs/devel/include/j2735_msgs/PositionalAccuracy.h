// Generated by gencpp from file j2735_msgs/PositionalAccuracy.msg
// DO NOT EDIT!


#ifndef J2735_MSGS_MESSAGE_POSITIONALACCURACY_H
#define J2735_MSGS_MESSAGE_POSITIONALACCURACY_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace j2735_msgs
{
template <class ContainerAllocator>
struct PositionalAccuracy_
{
  typedef PositionalAccuracy_<ContainerAllocator> Type;

  PositionalAccuracy_()
    : semiMajor(0)
    , semiMinor(0)
    , orientation(0)  {
    }
  PositionalAccuracy_(const ContainerAllocator& _alloc)
    : semiMajor(0)
    , semiMinor(0)
    , orientation(0)  {
  (void)_alloc;
    }



   typedef uint8_t _semiMajor_type;
  _semiMajor_type semiMajor;

   typedef uint8_t _semiMinor_type;
  _semiMinor_type semiMinor;

   typedef uint16_t _orientation_type;
  _orientation_type orientation;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(ACCURACY_UNAVAILABLE)
  #undef ACCURACY_UNAVAILABLE
#endif
#if defined(_WIN32) && defined(ACCURACY_MAX)
  #undef ACCURACY_MAX
#endif
#if defined(_WIN32) && defined(ACCURACY_MIN)
  #undef ACCURACY_MIN
#endif
#if defined(_WIN32) && defined(ACCURACY_ORIENTATION_UNAVAILABLE)
  #undef ACCURACY_ORIENTATION_UNAVAILABLE
#endif
#if defined(_WIN32) && defined(ACCURACY_ORIENTATION_MAX)
  #undef ACCURACY_ORIENTATION_MAX
#endif
#if defined(_WIN32) && defined(ACCURACY_ORIENTATION_MIN)
  #undef ACCURACY_ORIENTATION_MIN
#endif

  enum {
    ACCURACY_UNAVAILABLE = 255u,
    ACCURACY_MAX = 254u,
    ACCURACY_MIN = 0u,
    ACCURACY_ORIENTATION_UNAVAILABLE = 65535u,
    ACCURACY_ORIENTATION_MAX = 65534u,
    ACCURACY_ORIENTATION_MIN = 0u,
  };


  typedef boost::shared_ptr< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> const> ConstPtr;

}; // struct PositionalAccuracy_

typedef ::j2735_msgs::PositionalAccuracy_<std::allocator<void> > PositionalAccuracy;

typedef boost::shared_ptr< ::j2735_msgs::PositionalAccuracy > PositionalAccuracyPtr;
typedef boost::shared_ptr< ::j2735_msgs::PositionalAccuracy const> PositionalAccuracyConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::j2735_msgs::PositionalAccuracy_<ContainerAllocator1> & lhs, const ::j2735_msgs::PositionalAccuracy_<ContainerAllocator2> & rhs)
{
  return lhs.semiMajor == rhs.semiMajor &&
    lhs.semiMinor == rhs.semiMinor &&
    lhs.orientation == rhs.orientation;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::j2735_msgs::PositionalAccuracy_<ContainerAllocator1> & lhs, const ::j2735_msgs::PositionalAccuracy_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace j2735_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> >
{
  static const char* value()
  {
    return "993c06d8702326587d0e9f49bc843cde";
  }

  static const char* value(const ::j2735_msgs::PositionalAccuracy_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x993c06d870232658ULL;
  static const uint64_t static_value2 = 0x7d0e9f49bc843cdeULL;
};

template<class ContainerAllocator>
struct DataType< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> >
{
  static const char* value()
  {
    return "j2735_msgs/PositionalAccuracy";
  }

  static const char* value(const ::j2735_msgs::PositionalAccuracy_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#\n"
"# PositionalAccuracy.msg\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# @author Mae Fromm\n"
"# @version 0.1\n"
"#\n"
"# Used to model the accuracy of the positional determination with respect to each given axis.\n"
"\n"
"#PositionalAccuracy ::= SEQUENCE {\n"
"#   -- NMEA-183 values expressed in strict ASN form\n"
"#   semiMajor     SemiMajorAxisAccuracy,\n"
"#   semiMinor     SemiMinorAxisAccuracy,\n"
"#   orientation   SemiMajorAxisOrientation\n"
"#   }\n"
"\n"
"#SemiMajorAxisAccuracy ::= INTEGER (0..255)\n"
"#   -- semi-major/semi-minor axis accuracy at one standard dev\n"
"#   -- range 0-12.7 meter, LSB = .05m\n"
"#   -- 254 = any value equal or greater than 12.70 meter\n"
"#   -- 255 = unavailable semi-major axis value\n"
"#   -- Convert to meter with factor 0.05 when this field is used\n"
"uint8 semiMajor\n"
"uint8 semiMinor\n"
"\n"
"uint8 ACCURACY_UNAVAILABLE = 255\n"
"uint8 ACCURACY_MAX = 254\n"
"uint8 ACCURACY_MIN = 0\n"
"\n"
"#SemiMajorAxisOrientation ::= INTEGER (0..65535)\n"
"#   -- orientation of semi-major axis\n"
"#   -- relative to true north (0~359.9945078786 degrees)\n"
"#   -- LSB units of 360/65535 deg  = 0.0054932479\n"
"#   -- a value of 0 shall be 0 degrees\n"
"#   -- a value of 1 shall be 0.0054932479 degrees\n"
"#   -- a value of 65534 shall be 359.9945078786 deg\n"
"#   -- a value of 65535 shall be used for orientation unavailable\n"
"#   -- Convert to degree with factor 0.0054932479 when this field is used\n"
"uint16 orientation\n"
"\n"
"uint16 ACCURACY_ORIENTATION_UNAVAILABLE = 65535\n"
"uint16 ACCURACY_ORIENTATION_MAX = 65534\n"
"uint16 ACCURACY_ORIENTATION_MIN = 0\n"
;
  }

  static const char* value(const ::j2735_msgs::PositionalAccuracy_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.semiMajor);
      stream.next(m.semiMinor);
      stream.next(m.orientation);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct PositionalAccuracy_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::j2735_msgs::PositionalAccuracy_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::j2735_msgs::PositionalAccuracy_<ContainerAllocator>& v)
  {
    s << indent << "semiMajor: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.semiMajor);
    s << indent << "semiMinor: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.semiMinor);
    s << indent << "orientation: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.orientation);
  }
};

} // namespace message_operations
} // namespace ros

#endif // J2735_MSGS_MESSAGE_POSITIONALACCURACY_H
