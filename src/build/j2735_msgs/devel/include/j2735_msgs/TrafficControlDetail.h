// Generated by gencpp from file j2735_msgs/TrafficControlDetail.msg
// DO NOT EDIT!


#ifndef J2735_MSGS_MESSAGE_TRAFFICCONTROLDETAIL_H
#define J2735_MSGS_MESSAGE_TRAFFICCONTROLDETAIL_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace j2735_msgs
{
template <class ContainerAllocator>
struct TrafficControlDetail_
{
  typedef TrafficControlDetail_<ContainerAllocator> Type;

  TrafficControlDetail_()
    : choice(0)
    , signal()
    , closed(0)
    , chains(0)
    , direction(0)
    , lataffinity(0)
    , latperm()
    , parking(0)
    , minspeed(0)
    , maxspeed(0)
    , minhdwy(0)
    , maxvehmass(0)
    , maxvehheight(0)
    , maxvehwidth(0)
    , maxvehlength(0)
    , maxvehaxles(0)
    , minvehocc(0)  {
      latperm.assign(0);
  }
  TrafficControlDetail_(const ContainerAllocator& _alloc)
    : choice(0)
    , signal(_alloc)
    , closed(0)
    , chains(0)
    , direction(0)
    , lataffinity(0)
    , latperm()
    , parking(0)
    , minspeed(0)
    , maxspeed(0)
    , minhdwy(0)
    , maxvehmass(0)
    , maxvehheight(0)
    , maxvehwidth(0)
    , maxvehlength(0)
    , maxvehaxles(0)
    , minvehocc(0)  {
  (void)_alloc;
      latperm.assign(0);
  }



   typedef uint8_t _choice_type;
  _choice_type choice;

   typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _signal_type;
  _signal_type signal;

   typedef uint8_t _closed_type;
  _closed_type closed;

   typedef uint8_t _chains_type;
  _chains_type chains;

   typedef uint8_t _direction_type;
  _direction_type direction;

   typedef uint8_t _lataffinity_type;
  _lataffinity_type lataffinity;

   typedef boost::array<uint8_t, 2>  _latperm_type;
  _latperm_type latperm;

   typedef uint8_t _parking_type;
  _parking_type parking;

   typedef uint16_t _minspeed_type;
  _minspeed_type minspeed;

   typedef uint16_t _maxspeed_type;
  _maxspeed_type maxspeed;

   typedef uint16_t _minhdwy_type;
  _minhdwy_type minhdwy;

   typedef uint16_t _maxvehmass_type;
  _maxvehmass_type maxvehmass;

   typedef uint8_t _maxvehheight_type;
  _maxvehheight_type maxvehheight;

   typedef uint8_t _maxvehwidth_type;
  _maxvehwidth_type maxvehwidth;

   typedef uint16_t _maxvehlength_type;
  _maxvehlength_type maxvehlength;

   typedef uint8_t _maxvehaxles_type;
  _maxvehaxles_type maxvehaxles;

   typedef uint8_t _minvehocc_type;
  _minvehocc_type minvehocc;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(SIGNAL_CHOICE)
  #undef SIGNAL_CHOICE
#endif
#if defined(_WIN32) && defined(STOP_CHOICE)
  #undef STOP_CHOICE
#endif
#if defined(_WIN32) && defined(YIELD_CHOICE)
  #undef YIELD_CHOICE
#endif
#if defined(_WIN32) && defined(NOTOWING_CHOICE)
  #undef NOTOWING_CHOICE
#endif
#if defined(_WIN32) && defined(RESTRICTED_CHOICE)
  #undef RESTRICTED_CHOICE
#endif
#if defined(_WIN32) && defined(CLOSED_CHOICE)
  #undef CLOSED_CHOICE
#endif
#if defined(_WIN32) && defined(CHAINS_CHOICE)
  #undef CHAINS_CHOICE
#endif
#if defined(_WIN32) && defined(DIRECTION_CHOICE)
  #undef DIRECTION_CHOICE
#endif
#if defined(_WIN32) && defined(LATAFFINITY_CHOICE)
  #undef LATAFFINITY_CHOICE
#endif
#if defined(_WIN32) && defined(LATPERM_CHOICE)
  #undef LATPERM_CHOICE
#endif
#if defined(_WIN32) && defined(PARKING_CHOICE)
  #undef PARKING_CHOICE
#endif
#if defined(_WIN32) && defined(MINSPEED_CHOICE)
  #undef MINSPEED_CHOICE
#endif
#if defined(_WIN32) && defined(MAXSPEED_CHOICE)
  #undef MAXSPEED_CHOICE
#endif
#if defined(_WIN32) && defined(MINHDWY_CHOICE)
  #undef MINHDWY_CHOICE
#endif
#if defined(_WIN32) && defined(MAXVEHMASS_CHOICE)
  #undef MAXVEHMASS_CHOICE
#endif
#if defined(_WIN32) && defined(MAXVEHHEIGHT_CHOICE)
  #undef MAXVEHHEIGHT_CHOICE
#endif
#if defined(_WIN32) && defined(MAXVEHWIDTH_CHOICE)
  #undef MAXVEHWIDTH_CHOICE
#endif
#if defined(_WIN32) && defined(MAXVEHLENGTH_CHOICE)
  #undef MAXVEHLENGTH_CHOICE
#endif
#if defined(_WIN32) && defined(MAXVEHAXLES_CHOICE)
  #undef MAXVEHAXLES_CHOICE
#endif
#if defined(_WIN32) && defined(MINVEHOCC_CHOICE)
  #undef MINVEHOCC_CHOICE
#endif
#if defined(_WIN32) && defined(OPEN)
  #undef OPEN
#endif
#if defined(_WIN32) && defined(CLOSED)
  #undef CLOSED
#endif
#if defined(_WIN32) && defined(TAPERLEFT)
  #undef TAPERLEFT
#endif
#if defined(_WIN32) && defined(TAPERRIGHT)
  #undef TAPERRIGHT
#endif
#if defined(_WIN32) && defined(OPENLEFT)
  #undef OPENLEFT
#endif
#if defined(_WIN32) && defined(OPENRIGHT)
  #undef OPENRIGHT
#endif
#if defined(_WIN32) && defined(NO)
  #undef NO
#endif
#if defined(_WIN32) && defined(PERMITTED)
  #undef PERMITTED
#endif
#if defined(_WIN32) && defined(REQUIRED)
  #undef REQUIRED
#endif
#if defined(_WIN32) && defined(FORWARD)
  #undef FORWARD
#endif
#if defined(_WIN32) && defined(REVERSE)
  #undef REVERSE
#endif
#if defined(_WIN32) && defined(LEFT)
  #undef LEFT
#endif
#if defined(_WIN32) && defined(RIGHT)
  #undef RIGHT
#endif
#if defined(_WIN32) && defined(NONE)
  #undef NONE
#endif
#if defined(_WIN32) && defined(PASSINGONLY)
  #undef PASSINGONLY
#endif
#if defined(_WIN32) && defined(EMERGENCYONLY)
  #undef EMERGENCYONLY
#endif
#if defined(_WIN32) && defined(PARALLEL)
  #undef PARALLEL
#endif
#if defined(_WIN32) && defined(ANGLED)
  #undef ANGLED
#endif

  enum {
    SIGNAL_CHOICE = 0u,
    STOP_CHOICE = 1u,
    YIELD_CHOICE = 2u,
    NOTOWING_CHOICE = 3u,
    RESTRICTED_CHOICE = 4u,
    CLOSED_CHOICE = 5u,
    CHAINS_CHOICE = 6u,
    DIRECTION_CHOICE = 7u,
    LATAFFINITY_CHOICE = 8u,
    LATPERM_CHOICE = 9u,
    PARKING_CHOICE = 10u,
    MINSPEED_CHOICE = 11u,
    MAXSPEED_CHOICE = 12u,
    MINHDWY_CHOICE = 13u,
    MAXVEHMASS_CHOICE = 14u,
    MAXVEHHEIGHT_CHOICE = 15u,
    MAXVEHWIDTH_CHOICE = 16u,
    MAXVEHLENGTH_CHOICE = 17u,
    MAXVEHAXLES_CHOICE = 18u,
    MINVEHOCC_CHOICE = 19u,
    OPEN = 0u,
    CLOSED = 1u,
    TAPERLEFT = 2u,
    TAPERRIGHT = 3u,
    OPENLEFT = 4u,
    OPENRIGHT = 5u,
    NO = 0u,
    PERMITTED = 1u,
    REQUIRED = 2u,
    FORWARD = 0u,
    REVERSE = 1u,
    LEFT = 0u,
    RIGHT = 1u,
    NONE = 0u,
    PASSINGONLY = 2u,
    EMERGENCYONLY = 3u,
    PARALLEL = 1u,
    ANGLED = 2u,
  };


  typedef boost::shared_ptr< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> const> ConstPtr;

}; // struct TrafficControlDetail_

typedef ::j2735_msgs::TrafficControlDetail_<std::allocator<void> > TrafficControlDetail;

typedef boost::shared_ptr< ::j2735_msgs::TrafficControlDetail > TrafficControlDetailPtr;
typedef boost::shared_ptr< ::j2735_msgs::TrafficControlDetail const> TrafficControlDetailConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::j2735_msgs::TrafficControlDetail_<ContainerAllocator1> & lhs, const ::j2735_msgs::TrafficControlDetail_<ContainerAllocator2> & rhs)
{
  return lhs.choice == rhs.choice &&
    lhs.signal == rhs.signal &&
    lhs.closed == rhs.closed &&
    lhs.chains == rhs.chains &&
    lhs.direction == rhs.direction &&
    lhs.lataffinity == rhs.lataffinity &&
    lhs.latperm == rhs.latperm &&
    lhs.parking == rhs.parking &&
    lhs.minspeed == rhs.minspeed &&
    lhs.maxspeed == rhs.maxspeed &&
    lhs.minhdwy == rhs.minhdwy &&
    lhs.maxvehmass == rhs.maxvehmass &&
    lhs.maxvehheight == rhs.maxvehheight &&
    lhs.maxvehwidth == rhs.maxvehwidth &&
    lhs.maxvehlength == rhs.maxvehlength &&
    lhs.maxvehaxles == rhs.maxvehaxles &&
    lhs.minvehocc == rhs.minvehocc;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::j2735_msgs::TrafficControlDetail_<ContainerAllocator1> & lhs, const ::j2735_msgs::TrafficControlDetail_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace j2735_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> >
{
  static const char* value()
  {
    return "1729e85f043b0bad7ed698acb5917bcb";
  }

  static const char* value(const ::j2735_msgs::TrafficControlDetail_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x1729e85f043b0badULL;
  static const uint64_t static_value2 = 0x7ed698acb5917bcbULL;
};

template<class ContainerAllocator>
struct DataType< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> >
{
  static const char* value()
  {
    return "j2735_msgs/TrafficControlDetail";
  }

  static const char* value(const ::j2735_msgs::TrafficControlDetail_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#\n"
"# TrafficControlDetail.msg\n"
"#\n"
"# Part of the CARMA Cloud geo-fence specification not part of the official SAE j2735 standard\n"
"#\n"
"# J2735 2016 message format.\n"
"#\n"
"# \n"
"# @version 0.1\n"
"#\n"
"# Description\n"
"# ...\n"
"\n"
"#TrafficControlDetail ::= CHOICE\n"
"#{\n"
"#	signal OCTET STRING SIZE(0..63),\n"
"#	stop NULL,\n"
"#	yield NULL,\n"
"#	notowing NULL,\n"
"#	restricted NULL,\n"
"#	closed ENUMERATED {open, closed, taperleft, taperright, openleft, openright},\n"
"#	chains ENUMERATED {no, permitted, required},\n"
"#	direction ENUMERATED {forward, reverse},\n"
"#	lataffinity ENUMERATED {left, right},\n"
"#	latperm SEQUENCE (SIZE(2)) OF ENUMERATED {none, permitted, passing-only, emergency-only},\n"
"#	parking ENUMERATED {no, parallel, angled},\n"
"#	minspeed INTEGER (0..1023), -- tenths of m/s\n"
"#	maxspeed INTEGER (0..1023), -- tenths of m/s\n"
"#	minhdwy INTEGER (0..2047), -- tenths of meters\n"
"#	maxvehmass INTEGER (0..65535), -- kg\n"
"#	maxvehheight INTEGER (0..127), -- tenths of meters\n"
"#	maxvehwidth INTEGER (0..127), -- tenths of meters\n"
"#	maxvehlength INTEGER (0..1023), -- tenths of meters\n"
"#	maxvehaxles INTEGER (2..15),\n"
"#	minvehocc INTEGER (1..15), \n"
"#	...\n"
"#}\n"
"\n"
"\n"
"uint8 choice\n"
"\n"
"# enumeration values for choice:\n"
"\n"
"uint8 SIGNAL_CHOICE =0\n"
"uint8 STOP_CHOICE =1\n"
"uint8 YIELD_CHOICE =2\n"
"uint8 NOTOWING_CHOICE =3\n"
"uint8 RESTRICTED_CHOICE =4\n"
"uint8 CLOSED_CHOICE =5\n"
"uint8 CHAINS_CHOICE =6\n"
"uint8 DIRECTION_CHOICE =7\n"
"uint8 LATAFFINITY_CHOICE =8\n"
"uint8 LATPERM_CHOICE =9\n"
"uint8 PARKING_CHOICE =10\n"
"uint8 MINSPEED_CHOICE =11\n"
"uint8 MAXSPEED_CHOICE =12\n"
"uint8 MINHDWY_CHOICE =13\n"
"uint8 MAXVEHMASS_CHOICE =14\n"
"uint8 MAXVEHHEIGHT_CHOICE =15\n"
"uint8 MAXVEHWIDTH_CHOICE =16\n"
"uint8 MAXVEHLENGTH_CHOICE =17\n"
"uint8 MAXVEHAXLES_CHOICE =18\n"
"uint8 MINVEHOCC_CHOICE =19\n"
"\n"
"# signal ::= OCTET STRING SIZE(0..63)\n"
"uint8[] signal\n"
"\n"
"#closed ENUMERATED {open, closed, taperleft, taperright, openleft, openright}\n"
"\n"
"uint8 closed\n"
"\n"
"# enumeration values for closed:\n"
"\n"
"uint8 OPEN=0\n"
"\n"
"uint8 CLOSED=1\n"
"\n"
"uint8 TAPERLEFT=2\n"
"\n"
"uint8 TAPERRIGHT=3\n"
"\n"
"uint8 OPENLEFT=4\n"
"\n"
"uint8 OPENRIGHT=5\n"
"\n"
"#chains ENUMERATED {no, permitted, required}\n"
"\n"
"uint8 chains\n"
"\n"
"# enumeration values for chains:\n"
"\n"
"uint8 NO=0\n"
"\n"
"uint8 PERMITTED=1\n"
"\n"
"uint8 REQUIRED=2\n"
"\n"
"\n"
"#direction ENUMERATED {forward, reverse}\n"
"\n"
"uint8 direction\n"
"\n"
"# enumeration values for direction:\n"
"\n"
"uint8 FORWARD=0\n"
"\n"
"uint8 REVERSE=1\n"
"\n"
"#lataffinity ENUMERATED {left, right}\n"
"\n"
"uint8 lataffinity\n"
"\n"
"# enumeration values for lataffinity:\n"
"\n"
"uint8 LEFT=0\n"
"\n"
"uint8 RIGHT=1\n"
"\n"
"#latperm SEQUENCE (SIZE(2)) OF ENUMERATED {none, permitted, passing-only, emergency-only}\n"
"\n"
"uint8[2] latperm\n"
"\n"
"# enumeration values for latperm:\n"
"\n"
"uint8 NONE=0\n"
"\n"
"# uint8 PERMITTED=1 redeclaration\n"
"\n"
"uint8 PASSINGONLY=2\n"
"\n"
"uint8 EMERGENCYONLY=3\n"
"\n"
"#parking ENUMERATED {no, parallel, angled}\n"
"\n"
"uint8 parking\n"
"\n"
"# enumeration values for parking:\n"
"\n"
"# uint8 NO=0 redeclaration\n"
"\n"
"uint8 PARALLEL=1\n"
"\n"
"uint8 ANGLED=2\n"
"\n"
"#minspeed ::= INTEGER (0..1023), -- tenths of m/s\n"
"uint16 minspeed\n"
"\n"
"#maxspeed ::= INTEGER (0..1023), -- tenths of m/s\n"
"uint16 maxspeed\n"
"\n"
"#minhdwy ::= INTEGER (0..2047), -- tenths of meters\n"
"uint16 minhdwy\n"
"\n"
"#maxvehmass ::= INTEGER (0..65535), -- kg\n"
"uint16 maxvehmass\n"
"\n"
"#maxvehheight ::= INTEGER (0..127), -- tenths of meters\n"
"uint8 maxvehheight\n"
"\n"
"#maxvehwidth ::= INTEGER (0..127), -- tenths of meters\n"
"uint8 maxvehwidth\n"
"\n"
"#maxvehlength ::= INTEGER (0..1023), -- tenths of meters\n"
"uint16 maxvehlength\n"
"\n"
"#maxvehaxles ::= INTEGER (2..15)\n"
"uint8 maxvehaxles\n"
"\n"
"#minvehocc ::= INTEGER (1..15)\n"
"uint8 minvehocc\n"
"\n"
"\n"
"\n"
"\n"
;
  }

  static const char* value(const ::j2735_msgs::TrafficControlDetail_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.choice);
      stream.next(m.signal);
      stream.next(m.closed);
      stream.next(m.chains);
      stream.next(m.direction);
      stream.next(m.lataffinity);
      stream.next(m.latperm);
      stream.next(m.parking);
      stream.next(m.minspeed);
      stream.next(m.maxspeed);
      stream.next(m.minhdwy);
      stream.next(m.maxvehmass);
      stream.next(m.maxvehheight);
      stream.next(m.maxvehwidth);
      stream.next(m.maxvehlength);
      stream.next(m.maxvehaxles);
      stream.next(m.minvehocc);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct TrafficControlDetail_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::j2735_msgs::TrafficControlDetail_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::j2735_msgs::TrafficControlDetail_<ContainerAllocator>& v)
  {
    s << indent << "choice: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.choice);
    s << indent << "signal[]" << std::endl;
    for (size_t i = 0; i < v.signal.size(); ++i)
    {
      s << indent << "  signal[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.signal[i]);
    }
    s << indent << "closed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.closed);
    s << indent << "chains: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chains);
    s << indent << "direction: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.direction);
    s << indent << "lataffinity: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.lataffinity);
    s << indent << "latperm[]" << std::endl;
    for (size_t i = 0; i < v.latperm.size(); ++i)
    {
      s << indent << "  latperm[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.latperm[i]);
    }
    s << indent << "parking: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.parking);
    s << indent << "minspeed: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.minspeed);
    s << indent << "maxspeed: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.maxspeed);
    s << indent << "minhdwy: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.minhdwy);
    s << indent << "maxvehmass: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.maxvehmass);
    s << indent << "maxvehheight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.maxvehheight);
    s << indent << "maxvehwidth: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.maxvehwidth);
    s << indent << "maxvehlength: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.maxvehlength);
    s << indent << "maxvehaxles: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.maxvehaxles);
    s << indent << "minvehocc: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.minvehocc);
  }
};

} // namespace message_operations
} // namespace ros

#endif // J2735_MSGS_MESSAGE_TRAFFICCONTROLDETAIL_H
